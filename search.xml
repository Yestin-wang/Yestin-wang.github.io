<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++中二维数组作为函数的参数</title>
    <url>/2022/01/15/C++%E4%B8%AD%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>最近发现对c++的二维数组的传参产生遗忘，写此文来回顾下二维数组作为函数参数形式的传递。</p>
<span id="more"></span>

<h3 id="固定维度"><a href="#固定维度" class="headerlink" title="固定维度"></a>固定维度</h3><p>先定义一个三行三列数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>二维数组作为函数的参数，总体只有以下几种写法。函数的参数声明中必须指出数组的列数，与数组的行数没有太大的关系。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">(<span class="type">int</span> (*array)[<span class="number">3</span>])</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(*array)[3]传参成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">(<span class="type">int</span> array[<span class="number">3</span>][<span class="number">3</span>])</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;array[3][3]传参成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">(<span class="type">int</span> array[][<span class="number">3</span>])</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;array[][3]传参成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下几种方式是不合法的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">(<span class="type">int</span> array[][])</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span><span class="params">(<span class="type">int</span> array[<span class="number">3</span>][])</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这种写法是相当于声明了一个数组，该数组包含着3个指向整型对象的指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test06</span><span class="params">(<span class="type">int</span> *arr[<span class="number">3</span>])</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态二维数组"><a href="#动态二维数组" class="headerlink" title="动态二维数组"></a>动态二维数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vla</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n,<span class="type">int</span> arr[m][n])</span></span>&#123;&#125;		<span class="comment">//正确</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vla</span><span class="params">(<span class="type">int</span> arr[m][n]，<span class="type">int</span> m,<span class="type">int</span> n)</span></span>&#123;&#125;	   <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>很奇怪，VS 2022社区版的编译器竟然不支持VLA。</p>
<h3 id="vector的形式使用二维数组"><a href="#vector的形式使用二维数组" class="headerlink" title="vector的形式使用二维数组"></a>vector的形式使用二维数组</h3><p>对于不支持VLA的编译器完全可以用vector替代数组形式。如建立一个n行n列的布尔型二维数组变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line">vector &lt; vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">putQ</span>(n,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n,<span class="literal">true</span>));<span class="comment">//设置初值为真</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++学习笔记</category>
        <category>C++拾遗</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ STL常用算法</title>
    <url>/2022/02/12/C++STL%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>标准模板库 STL（Standard Template Library）是C++标准库的一部分，是借助模板把常用的数据结构及算法封装在其中。掌握STL对于刷算法题有很大的帮助。写此文来记录总结下STL中的常用函数</p>
<span id="more"></span>

<h1 id="常用遍历算法"><a href="#常用遍历算法" class="headerlink" title="常用遍历算法"></a>常用遍历算法</h1><p>以下算法都在头文件&lt;algorithm&gt;中</p>
<h2 id="for-each-实现遍历容器"><a href="#for-each-实现遍历容器" class="headerlink" title="for_each  实现遍历容器"></a><strong>for_each</strong>  实现遍历容器</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">for_each(iterator beg, iterator end, _func);<span class="comment">//beg 开始迭代器	end 结束迭代器  _func 函数或者函数对象</span></span><br></pre></td></tr></table></figure>

<p> _func传入普通函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vecPrint</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;			<span class="comment">//定义普通函数</span></span><br><span class="line">	cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v = &#123; <span class="number">2</span>,<span class="number">3</span>,<span class="number">43</span>,<span class="number">324</span>,<span class="number">234</span>,<span class="number">123</span>,<span class="number">2345</span>,<span class="number">435</span>,<span class="number">34</span> &#125;;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), vecPrint);<span class="comment">//遍历输出v容器中的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>​	2 3 43 324 234 123 2345 435 34</p>
</blockquote>
<p> _func传入仿函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">printFunctor</span>&#123;		<span class="comment">//创造仿函数,打印数据</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v = &#123; <span class="number">2</span>,<span class="number">3</span>,<span class="number">43</span>,<span class="number">324</span>,<span class="number">234</span>,<span class="number">123</span>,<span class="number">2345</span>,<span class="number">435</span>,<span class="number">34</span> &#125;;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">printFunctor</span>());<span class="comment">//遍历输出v容器中的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>2 3 43 324 234 123 2345 435 34</p>
</blockquote>
<!-- more -->

<h2 id="transform搬运容器到另一个容器"><a href="#transform搬运容器到另一个容器" class="headerlink" title="transform搬运容器到另一个容器"></a>transform搬运容器到另一个容器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform(iterator beg1, iterator end1, iterator beg2, _func);//beg1 源容器开始迭代器	end1 源容器结束迭代器 beg2 目标容器开始迭代器 _func 函数或者函数对象</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trans</span> &#123;<span class="comment">//仿函数实现将数据元素+10操作</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val+<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;vTarget;</span><br><span class="line">	vTarget.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());<span class="comment">//为vTraget容器开辟与v容器等大的空间，否则程序运行会被中止</span></span><br><span class="line">	<span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),vTarget.<span class="built_in">begin</span>(), <span class="built_in">Trans</span>());<span class="comment">//将v容器中的数据+10后搬运到vTarget中</span></span><br><span class="line">	for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">printFunctor</span>());<span class="comment">//打印vTarget容器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>11 12 13 14 15 16 17 18 19</p>
</blockquote>
<h1 id="常用查找算法"><a href="#常用查找算法" class="headerlink" title="常用查找算法"></a>常用查找算法</h1><h2 id="find查找指定元素"><a href="#find查找指定元素" class="headerlink" title="find查找指定元素"></a>find查找指定元素</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find(iterator beg.iterator end,value)//value为查找的元素，找到返回指定元素的迭代器，否则返回end()</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it; <span class="comment">//定义一个迭代器</span></span><br><span class="line">	<span class="type">int</span> toFind=<span class="number">1</span>; <span class="comment">//待查找的数据</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;原始数据展示:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">printFunctor</span>());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">while</span> (toFind) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;待查找值:&quot;</span>;</span><br><span class="line">		cin &gt;&gt; toFind;</span><br><span class="line">		it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), toFind);</span><br><span class="line">		<span class="keyword">if</span> (it != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;找到&quot;</span> &lt;&lt; toFind &lt;&lt; <span class="string">&quot;了&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;找不着&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>原始数据展示:<br>1 2 3 4 5 6 7 8 9</p>
<p>待查找值:2<br>找到2了<br>待查找值:0<br>找不着</p>
</blockquote>
<p>以上是对常用数据类型查找的示例演示，但试想以下，如果数据类型不是常用的int，char，string之类的，而是自己定义的结构体类型，我们知道如果要判定自己定义的数据类型是否相等要写重载函数的，编译器是不支持自定义数据类型的判等之类的操作的，所以对于自定义数据类型，find函数自然也不会执行成功，该如何修改程序呢？</p>
<p>首先把自定义数据类型与重载函数设计好</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string p_name;</span><br><span class="line">	<span class="type">int</span> p_age;</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;p_age = age;</span><br><span class="line">		<span class="keyword">this</span>-&gt;p_name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来就以查找成功的案例演示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;Person&gt;v;</span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;吴京&quot;</span>, <span class="number">45</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;郭帆&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;吴孟达&quot;</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;李雪健&quot;</span>, <span class="number">71</span>)</span></span>;</span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	vector&lt;Person&gt;::iterator it;<span class="comment">//定义一个迭代器</span></span><br><span class="line">	it=<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p1);<span class="comment">//查找p1,it返回查找指定值的迭代器</span></span><br><span class="line">	<span class="keyword">if</span> (it != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;找着&quot;</span> &lt;&lt; it-&gt;p_name &lt;&lt; <span class="string">&quot;了  &quot;</span> &lt;&lt;<span class="string">&quot;年龄:&quot;</span>&lt;&lt;it-&gt;p_age&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>找着吴京了  年龄:45</p>
</blockquote>
<h2 id="find-if-按条件查找元素"><a href="#find-if-按条件查找元素" class="headerlink" title="find_if 按条件查找元素"></a><strong>find_if</strong> 按条件查找元素</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find_if(iterator beg,iterator end, _Pred);//_Pred 函数或者谓词</span><br></pre></td></tr></table></figure>

<p>以在1-10数值查找大于5的数为例，来看一看 <strong>find_if</strong> 的效果</p>
<p>写一个判定大于5的谓词</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GT5</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val&gt;<span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来展示一下 <strong>find_if</strong> 的效果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it= <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GT5</span>());</span><br><span class="line">	cout &lt;&lt; *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>6</p>
</blockquote>
<p>可以看到，函数返回的是查找到的第一个符合条件的元素的迭代器。</p>
<p>对于自定义类型的数据，需要在写谓词的时候写出适合该数据类型的合适方法。比如拿之前写好的Person类，你需要比较年龄，就写关于年龄比较的仿函数。</p>
<h2 id="adjacent-find-查找相邻重复元素"><a href="#adjacent-find-查找相邻重复元素" class="headerlink" title="adjacent_find 查找相邻重复元素"></a><strong>adjacent_find</strong> 查找相邻重复元素</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adjacent_find(iterator beg, iterator end);</span><br></pre></td></tr></table></figure>

<p>很简单，返回第一个相邻的重复元素</p>
<p>对于自定义的数据类型需要单独写函数或者仿函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">(<span class="type">const</span> Person&amp; p)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; p.p_name &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; p.p_age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;Person&gt;v;</span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;吴京&quot;</span>, <span class="number">45</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;郭帆&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;吴孟达&quot;</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;李雪健&quot;</span>, <span class="number">71</span>)</span></span>;</span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	vector&lt;Person&gt;::iterator it;<span class="comment">//定义一个迭代器</span></span><br><span class="line">	it=<span class="built_in">adjacent_find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());<span class="comment">//查找p1,it返回查找指定值的迭代器</span></span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), showPerson);</span><br><span class="line">	<span class="keyword">if</span> (it != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt;<span class="string">&quot;相邻重复元素&quot;</span> &lt;&lt; it-&gt;p_name &lt;&lt; <span class="string">&quot; 的年龄:&quot;</span> &lt;&lt; it-&gt;p_age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>吴京 : 45<br>吴京 : 45<br>郭帆 : 40<br>郭帆 : 40<br>吴孟达 : 60<br>李雪健 : 71<br>相邻重复元素吴京 的年龄:45</p>
</blockquote>
<h2 id="binary-search-二分查找"><a href="#binary-search-二分查找" class="headerlink" title="binary_search 二分查找"></a>binary_search 二分查找</h2><p>返回的是布尔类型   </p>
<p><font color='red'>适用于有序数列</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool binary_search(iterator beg, iterator end, value);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v = &#123; <span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;查找7找到没？&quot;</span>&lt;&lt;<span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<p>查找7找到没？1</p>
<h2 id="count-统计元素个数"><a href="#count-统计元素个数" class="headerlink" title="count 统计元素个数"></a><strong>count</strong> 统计元素个数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">count(iterator beg,iterator end,value);</span><br></pre></td></tr></table></figure>

<p>统计自定义数据类型要实现&#x3D;&#x3D;的重载</p>
<h2 id="count-if-按条件统计元素个数"><a href="#count-if-按条件统计元素个数" class="headerlink" title="count_if 按条件统计元素个数"></a><strong>count_if</strong> 按条件统计元素个数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">count_if(iterator beg, iterator end, _Pred);</span><br></pre></td></tr></table></figure>

<p>方法同样是分内建数据类型和自定义数据类型两种实现方式，归根到底的区别在于谓词的设计上的不同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FindByAge</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person &amp;P)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> P.p_age ==<span class="number">40</span>;<span class="comment">//查找年龄等于40的Person数据</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GT5</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt; <span class="number">5</span>;<span class="comment">//查找值大于5的数据</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="常见排序算法"><a href="#常见排序算法" class="headerlink" title="常见排序算法"></a>常见排序算法</h1><h2 id="sort-容器内数据排序"><a href="#sort-容器内数据排序" class="headerlink" title="sort 容器内数据排序"></a>sort 容器内数据排序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sort(iterator beg, iterator end, _Pred);</span><br></pre></td></tr></table></figure>

<p>将容器内的数据逆序案例:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">decrease</span> &#123; 	<span class="comment">//递减仿函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val1, <span class="type">int</span> val2)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v = &#123; <span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line">	<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),<span class="built_in">decrease</span>());</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">printFunctor</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>10 9 8 7 4 4 3 3 2 2</p>
</blockquote>
<h2 id="random-shuffle-指定范围内的元素随机调整次序"><a href="#random-shuffle-指定范围内的元素随机调整次序" class="headerlink" title="random_shuffle 指定范围内的元素随机调整次序"></a>random_shuffle 指定范围内的元素随机调整次序</h2><p>使用时加随机数种子，使数据更有随机性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">random_shuffle(iterator beg, iterator end);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">(<span class="type">const</span> Person&amp; p)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; p.p_name &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; p.p_age;</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//打印输出Person</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;Person&gt;v;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));<span class="comment">//创建随机数种子</span></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;吴京&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;郭帆&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;吴孟达&quot;</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;李雪健&quot;</span>, <span class="number">71</span>)</span></span>;</span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	vector&lt;Person&gt;::iterator it;<span class="comment">//定义一个迭代器</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;原始数据：&quot;</span>;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), showPerson);</span><br><span class="line">	<span class="built_in">random_shuffle</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	cout &lt;&lt;endl&lt;&lt; <span class="string">&quot;洗牌后的数据: &quot;</span>;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), showPerson);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>原始数据：   吴京 : 40   郭帆 : 40   郭帆 : 40   吴孟达 : 60   吴孟达 : 60   李雪健 : 71   李雪健 : 71<br>洗牌后的数据:    吴孟达 : 60   郭帆 : 40   李雪健 : 71   郭帆 : 40   吴京 : 40   李雪健 : 71   吴孟达 : 60</p>
</blockquote>
<h2 id="merge-合并两个容器，并存储到另一个容器"><a href="#merge-合并两个容器，并存储到另一个容器" class="headerlink" title="merge 合并两个容器，并存储到另一个容器"></a>merge 合并两个容器，并存储到另一个容器</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v2;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v3;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>;i &gt;<span class="number">0</span>;i--) &#123;<span class="comment">//两个降序序列</span></span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">		v2.<span class="built_in">push_back</span>(i+<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	v3.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());<span class="comment">//为v3分配容量</span></span><br><span class="line">	<span class="built_in">merge</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v3.<span class="built_in">begin</span>(),<span class="built_in">decrease</span>());<span class="comment">//设置谓词，实现降序排列</span></span><br><span class="line">	for_each(v3.<span class="built_in">begin</span>(), v3.<span class="built_in">end</span>(), <span class="built_in">printFunctor</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong>_</p>
<blockquote>
<p>13 12 11 10 10 9 9 8 8 7 7 6 6 5 5 4 4 3 2 1</p>
</blockquote>
<p> 默认是按升序排列，如果升序排列需要排序的两个数列皆为升序；如是自定义数据类型或者如案例中非默认方式排列，就需要自己写相关的谓词。注意升序则都升序，降序都降序，否则运行会中止</p>
<h2 id="reverse-反转"><a href="#reverse-反转" class="headerlink" title="__reverse __反转"></a>__reverse __反转</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reverse(iterator beg, iterator end);</span><br></pre></td></tr></table></figure>

<h1 id="常用拷贝和替换算法"><a href="#常用拷贝和替换算法" class="headerlink" title="常用拷贝和替换算法"></a>常用拷贝和替换算法</h1><h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy(iterator beg, iterator end,iterator dest)//dest目标容器起始迭代器</span><br></pre></td></tr></table></figure>

<p>下面的案例是拷贝一个自定义数据类型容器的案例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string p_name;</span><br><span class="line">	<span class="type">int</span> p_age;</span><br><span class="line">	<span class="built_in">Person</span>(string name=<span class="string">&quot;&quot;</span>, <span class="type">int</span> age = <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;p_age = age;</span><br><span class="line">		<span class="keyword">this</span>-&gt;p_name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;p_name == p.p_name &amp;&amp; <span class="keyword">this</span>-&gt;p_age == p.p_age)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;Person&gt;v;</span><br><span class="line">	vector&lt;Person&gt;v1;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;吴京&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;郭帆&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;吴孟达&quot;</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;李雪健&quot;</span>, <span class="number">71</span>)</span></span>;</span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v1.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());<span class="comment">//为v1开辟与v相等的空间</span></span><br><span class="line">	vector&lt;Person&gt;::iterator it;<span class="comment">//定义一个迭代器，此时Person类一定要有默认构造函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;原始数据：&quot;</span>;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), showPerson);</span><br><span class="line">	<span class="built_in">copy</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>());</span><br><span class="line">	cout &lt;&lt;endl&lt;&lt; <span class="string">&quot;拷贝后的数据: &quot;</span>;</span><br><span class="line">	for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), showPerson);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>原始数据：   吴京 : 40   郭帆 : 40   郭帆 : 40   吴孟达 : 60   吴孟达 : 60   李雪健 : 71   李雪健 : 71<br>拷贝后的数据:    吴京 : 40   郭帆 : 40   郭帆 : 40   吴孟达 : 60   吴孟达 : 60   李雪健 : 71   李雪健 : 71</p>
</blockquote>
<h2 id="replace-将容器内指定范围的旧元素修改为新元素"><a href="#replace-将容器内指定范围的旧元素修改为新元素" class="headerlink" title="replace 将容器内指定范围的旧元素修改为新元素"></a><strong>replace</strong> 将容器内指定范围的旧元素修改为新元素</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">replace(iterator beg, iterator end, oldvalue, newvalue)</span><br></pre></td></tr></table></figure>

<p>下列案例将吴京的数据替换成郭帆的数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;Person&gt;v;</span><br><span class="line">	vector&lt;Person&gt;v1;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建数据</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;吴京&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;郭帆&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;吴孟达&quot;</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;李雪健&quot;</span>, <span class="number">71</span>)</span></span>;</span><br><span class="line">	v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	vector&lt;Person&gt;::iterator it;<span class="comment">//定义一个迭代器</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;原始数据：&quot;</span>;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), showPerson);</span><br><span class="line">	<span class="built_in">replace</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p1,p2);<span class="comment">//将吴京替换成郭帆</span></span><br><span class="line">	cout &lt;&lt;endl&lt;&lt; <span class="string">&quot;替换后的数据: &quot;</span>;</span><br><span class="line">	for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), showPerson);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>原始数据：   吴京 : 40   郭帆 : 40   郭帆 : 40   吴孟达 : 60   吴孟达 : 60   李雪健 : 71   李雪健 : 71<br>替换后的数据:    郭帆 : 40   郭帆 : 40   郭帆 : 40   吴孟达 : 60   吴孟达 : 60   李雪健 : 71   李雪健 : 71</p>
</blockquote>
<p><strong>replace</strong>  是将所有的吴京都替换成郭帆</p>
<h2 id="replace-if-将区间内满足条件的元素替换成指定元素"><a href="#replace-if-将区间内满足条件的元素替换成指定元素" class="headerlink" title="replace_if 将区间内满足条件的元素替换成指定元素"></a>replace_if 将区间内满足条件的元素替换成指定元素</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">replace_if(iterator beg, iterator end, _pred, newvalue);</span><br></pre></td></tr></table></figure>

<p>将年龄大于40人的数据都替换成郭帆</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ageG40 &#123;</span><br><span class="line">public:</span><br><span class="line">	bool operator()(const Person &amp;P) &#123;</span><br><span class="line">		return P.p_age &gt; 40;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test1() &#123;</span><br><span class="line">	vector&lt;Person&gt;v;</span><br><span class="line">	vector&lt;Person&gt;v1;</span><br><span class="line"></span><br><span class="line">	//创建数据</span><br><span class="line">	Person p1(&quot;吴京&quot;, 40);</span><br><span class="line">	Person p2(&quot;郭帆&quot;, 40);</span><br><span class="line">	Person p3(&quot;吴孟达&quot;, 60);</span><br><span class="line">	Person p4(&quot;李雪健&quot;, 71);</span><br><span class="line">	v.push_back(p1);</span><br><span class="line">	v.push_back(p2);</span><br><span class="line">	v.push_back(p2);</span><br><span class="line">	v.push_back(p3);</span><br><span class="line">	v.push_back(p3);</span><br><span class="line">	v.push_back(p4);</span><br><span class="line">	v.push_back(p4);</span><br><span class="line">	vector&lt;Person&gt;::iterator it;//定义一个迭代器</span><br><span class="line">	cout &lt;&lt; &quot;原始数据：&quot;;</span><br><span class="line">	for_each(v.begin(), v.end(), showPerson);</span><br><span class="line">	replace_if(v.begin(), v.end(),ageG40(), p2);//将年龄大于40的都替换成郭帆数据</span><br><span class="line">	cout &lt;&lt;endl&lt;&lt; &quot;替换后的数据: &quot;;</span><br><span class="line">	for_each(v.begin(), v.end(), showPerson);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>运行结果</strong></p>
<blockquote>
<p>原始数据：   吴京 : 40   郭帆 : 40   郭帆 : 40   吴孟达 : 60   吴孟达 : 60   李雪健 : 71   李雪健 : 71<br>替换后的数据:    吴京 : 40   郭帆 : 40   郭帆 : 40   郭帆 : 40   郭帆 : 40   郭帆 : 40   郭帆 : 40</p>
</blockquote>
<h2 id="swap"><a href="#swap" class="headerlink" title="swap"></a><strong>swap</strong></h2><p>互换两个容器的元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swap(container c1, container c2);//c1, c2两个同种类型的容器</span><br></pre></td></tr></table></figure>

<h1 id="算术生成算法"><a href="#算术生成算法" class="headerlink" title="算术生成算法"></a>算术生成算法</h1><blockquote>
<p>#include &lt;numeric&gt;</p>
</blockquote>
<h2 id="accumulate-计算容器元素累计总和"><a href="#accumulate-计算容器元素累计总和" class="headerlink" title="accumulate 计算容器元素累计总和"></a>accumulate 计算容器元素累计总和</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">accumulate(iterator beg,iterator end, value);//计算容器元素累计总和 value起始值</span><br></pre></td></tr></table></figure>

<h2 id="fill-容器填充"><a href="#fill-容器填充" class="headerlink" title="fill 容器填充"></a><strong>fill</strong> 容器填充</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fill (iterator beg.iterator end, value);//向容器填充value</span><br></pre></td></tr></table></figure>

<h1 id="集合算法"><a href="#集合算法" class="headerlink" title="集合算法"></a>集合算法</h1><h2 id="交集-set-intersection"><a href="#交集-set-intersection" class="headerlink" title="交集  set_intersection"></a>交集  <strong>set_intersection</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set_intersection(iterator beg1, iterator end1,iterator beg2, iterator end2,iterator dest)//dest目标容器起始迭代器</span><br></pre></td></tr></table></figure>

<h2 id="并集-set-union"><a href="#并集-set-union" class="headerlink" title="并集  set_union"></a>并集  <strong>set_union</strong></h2><h2 id="差集-set-difference"><a href="#差集-set-difference" class="headerlink" title="差集  set_difference"></a>差集  <strong>set_difference</strong></h2>]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++函数对象</title>
    <url>/2022/01/18/C++%E6%8B%BE%E9%81%97%E4%B9%8B%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>函数对象在C++编程中尤为重要，它可以帮助我们实现STL库中的函数按照自己的方法来实现功能，以及自定义数据结构的排序、查找等功能。</p>
<span id="more"></span>

<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><ul>
<li>函数对象是重载函数调用操作符的类的对象，也叫仿函数</li>
<li>函数对象可以有参数和返回值，可以作为参数传递</li>
</ul>
<p>​	以下代码是一个仿函数实例，可以通过重载小括号实现两个数的相加。当然，不仅可以实现加法功能，四则运算，排序，输出打印功能均可实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个仿函数实例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FunctorAdd</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count += <span class="number">1</span>;<span class="comment">//每次调用count+1</span></span><br><span class="line">		<span class="keyword">return</span> v1 + v2;<span class="comment">//实际实现了括号的两个数相加</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="type">int</span> count;<span class="comment">//记录运行加法的次数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FunctorAdd add;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	上述代码还可以发现，如果在仿函数类中设置一个能够记录状态的变量（本例中的count），我们可以根据需求记录函数对象的状态。</p>
<p>​	仿函数的写法非常的灵活，也可以作为参数进行传递。如下面这段代码。doAdd()函数实现的功能即为两个数的相加。运行结果为35.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">doAdd</span><span class="params">(FunctorAdd func, <span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">func</span>(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FunctorAdd func;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">doAdd</span>(func,<span class="number">12</span>, <span class="number">23</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-谓词"><a href="#2-谓词" class="headerlink" title="2 谓词"></a>2 谓词</h2><ul>
<li>返回类型为bool的仿函数称为谓词</li>
<li>operator()接受一个参数称为一元谓词</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一元谓词</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FunctorGF</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v = &#123; <span class="number">1</span>,<span class="number">34</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">43</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">343</span>,<span class="number">423</span>,<span class="number">42</span>,<span class="number">4</span> &#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line">	<span class="comment">// FunctorGF()匿名函数对象,查找有没有大于5的数字</span></span><br><span class="line">	iter=<span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">FunctorGF</span>());</span><br><span class="line">	<span class="keyword">if</span> (iter == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;not find&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;at least a number is greater than 5&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>operator()接受两个参数称为二元谓词</li>
</ul>
<p>​	二元谓词最经典的案例就是排序了。STL中很多容器都可以加入自定义的排序规则。不妨写一个set容器的降序排列的实现方法作为二元谓词的案例。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二元谓词</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FunctorCmp</span>&#123;	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;<span class="comment">//实现降序排列</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;<span class="type">int</span>,FunctorCmp&gt;s = &#123; <span class="number">1</span>,<span class="number">34</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">43</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">43</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">343</span>,<span class="number">423</span>,<span class="number">42</span>,<span class="number">4</span> &#125;;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line">	<span class="keyword">for</span> (iter = s.<span class="built_in">begin</span>();iter != s.<span class="built_in">end</span>();iter++)</span><br><span class="line">		cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<blockquote>
<p>423 343 43 42 34 23 4 3 2 1</p>
</blockquote>
<h2 id="3-内建函数对象"><a href="#3-内建函数对象" class="headerlink" title="3 内建函数对象"></a>3 内建函数对象</h2><p>​	STL内建了一些函数对象，整体分为关系仿函数、逻辑仿函数和算术仿函数三类。这些仿函数所产生的对象用法和一般函数完全相同，但使用时需要引入头文件</p>
<blockquote>
<p>#include &lt;functional&gt;</p>
</blockquote>
<h3 id="3-1-关系仿函数"><a href="#3-1-关系仿函数" class="headerlink" title="3.1 关系仿函数"></a>3.1 关系仿函数</h3><blockquote>
<p>template<class T>  bool  equal_to<T>  &#x2F;&#x2F;等于</p>
<p>template<class T>  bool  not_ equal_to<T>  &#x2F;&#x2F;不等于</p>
<p>template<class T>  bool  greater<T>  &#x2F;&#x2F;大于</p>
<p>template<class T>  bool  greater_equal<T>  &#x2F;&#x2F;大于等于</p>
<p>template<class T>  bool  less<T>  &#x2F;&#x2F;小于</p>
<p>template<class T>  bool  less_equal<T>  &#x2F;&#x2F;小于等于</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; test;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">		test.<span class="built_in">push_back</span>(i * <span class="number">3</span>);<span class="comment">//0 3 6 9 12 15 18 21 24 27</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());<span class="comment">//把它整成降序</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;descending order：&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">		cout &lt;&lt; test[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">sort</span>(test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());<span class="comment">//再把它整成升序</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;increasing order：&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">		cout &lt;&lt; test[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<blockquote>
<p>descending order：27 24 21 18 15 12 9 6 3 0<br>increasing order：0 3 6 9 12 15 18 21 24 27</p>
</blockquote>
<h3 id="3-2-逻辑仿函数"><a href="#3-2-逻辑仿函数" class="headerlink" title="3.2 逻辑仿函数"></a>3.2 逻辑仿函数</h3><p>​	实现与或非的逻辑运算</p>
<blockquote>
<p>template<class T> bool logical_and<T>  &#x2F;&#x2F;逻辑与</p>
<p>template<class T> bool logical_or<T>  &#x2F;&#x2F;逻辑或</p>
<p>template<class T> bool logical_not<T>  &#x2F;&#x2F;逻辑非</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">bool</span>&gt; v1 = &#123; <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span> &#125;;</span><br><span class="line">	vector&lt;<span class="type">bool</span>&gt; v2 = &#123; <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">true</span> &#125;;</span><br><span class="line">	vector&lt;<span class="type">bool</span>&gt; res;</span><br><span class="line">	res.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>());</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;raw data v1: &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++) &#123;</span><br><span class="line">		cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;raw data v2: &quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++) &#123;</span><br><span class="line">		cout &lt;&lt; v2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;logical not data: &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//用transform函数实现数据转化，存储在res容器中</span></span><br><span class="line">	<span class="built_in">transform</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), res.<span class="built_in">begin</span>(), <span class="built_in">logical_not</span>&lt;<span class="type">bool</span>&gt;());</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; not &quot;</span> &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; res[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;logical and data: &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">transform</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), res.<span class="built_in">begin</span>(), <span class="built_in">logical_and</span>&lt;<span class="type">bool</span>&gt;());</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++) &#123;</span><br><span class="line">		cout &lt;&lt;v1[i] &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; v2[i] &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; res[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;logical or data: &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">transform</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), res.<span class="built_in">begin</span>(), <span class="built_in">logical_or</span>&lt;<span class="type">bool</span>&gt;());</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++) &#123;</span><br><span class="line">		cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; or &quot;</span> &lt;&lt; v2[i] &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt;res[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<blockquote>
<p>raw data v1: 1 0 1 0 1<br>raw data v2: 1 1 0 0 1<br>logical not data:<br>not 1 &#x3D; 0<br>not 0 &#x3D; 1<br>not 1 &#x3D; 0<br>not 0 &#x3D; 1<br>not 1 &#x3D; 0<br>logical and data:<br>1 and 1 &#x3D; 1<br>0 and 1 &#x3D; 0<br>1 and 0 &#x3D; 0<br>0 and 0 &#x3D; 0<br>1 and 1 &#x3D; 1</p>
<p>logical or data:<br>1 or 1 &#x3D; 1<br>0 or 1 &#x3D; 1<br>1 or 0 &#x3D; 1<br>0 or 0 &#x3D; 0<br>1 or 1 &#x3D; 1</p>
</blockquote>
<h3 id="3-3-算术仿函数"><a href="#3-3-算术仿函数" class="headerlink" title="3.3 算术仿函数"></a>3.3 算术仿函数</h3><blockquote>
<p>template<class T>  T plus<T>	   	 &#x2F;&#x2F;加法仿函数</p>
<p>template<class T>  T minus<T>	    &#x2F;&#x2F;减法仿函数</p>
<p>template<class T>  T multiplies<T> &#x2F;&#x2F;乘法仿函数</p>
<p>template<class T>  T divides<T>	  &#x2F;&#x2F;除法仿函数</p>
<p>template<class T>  T negate<T>	  &#x2F;&#x2F;取反仿函数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FunctorCmp</span>&#123;	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span><span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1 &gt; v2;<span class="comment">//实现降序排列</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	plus&lt;<span class="type">int</span>&gt;plus;</span><br><span class="line">	minus&lt;<span class="type">int</span>&gt;min;</span><br><span class="line">	multiplies&lt;<span class="type">int</span>&gt;mul;</span><br><span class="line">	divides&lt;<span class="type">int</span>&gt;div;</span><br><span class="line">	negate&lt;<span class="type">int</span>&gt;neg;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;plus functor: 13+14=&quot;</span> &lt;&lt; <span class="built_in">plus</span>(<span class="number">13</span>, <span class="number">14</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;minus functor: 13-14=&quot;</span> &lt;&lt; <span class="built_in">min</span>(<span class="number">13</span>, <span class="number">14</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;multiplies functor: 13*14=&quot;</span> &lt;&lt; <span class="built_in">mul</span>(<span class="number">13</span>, <span class="number">14</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;divides functor: 28/14=&quot;</span> &lt;&lt; <span class="built_in">div</span>(<span class="number">28</span>, <span class="number">14</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;negate functor: -20=&quot;</span> &lt;&lt; <span class="built_in">neg</span>(<span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<blockquote>
<p>plus functor: 13+14&#x3D;27<br>minus functor: 13-14&#x3D;-1<br>multiplies functor: 13*14&#x3D;182<br>divides functor: 28&#x2F;14&#x3D;2<br>negate functor: -20&#x3D;-20</p>
</blockquote>
]]></content>
      <categories>
        <category>C++学习笔记</category>
        <category>C++拾遗</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础操作(上)</title>
    <url>/2023/01/20/Linux%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>本文介绍Linux系统下的vim操作、用户和组的管理、权限管理、文件目录操作、搜索查找、压缩解压、时间日期以及运行级别方面的基础操作</p>
<span id="more"></span>

<h3 id="vim常用快捷键"><a href="#vim常用快捷键" class="headerlink" title="vim常用快捷键"></a>vim常用快捷键</h3><ul>
<li>拷贝当前行 [yy]	拷贝当前行的向下n  [nyy] 	粘贴  [p]</li>
<li>删除当前行 [dd]	删除当前行向下n行 [ndd] </li>
<li>查找关键字 	命令行状态    [&#x2F;关键字]</li>
<li>设置文件的行号&#x2F;取消行号   命令行状态   [:set nu&#x2F;set nonu]</li>
<li>编辑文件的最末行 [G]   最首行  [gg]</li>
<li>撤销 [u]</li>
<li>定位到具体行 [行号]+[shift]+[g]</li>
<li>屏幕向下移动一页  [ctrl]+[f]</li>
<li>屏幕向上移动一页  [ctrl]+[b]</li>
<li>屏幕向下移动半页  [ctrl]+[d]</li>
<li>屏幕向上移动半页  [ctrl]+[u]</li>
<li>屏幕最上方的那一行 [H]</li>
<li>屏幕中央的那一行 [M]</li>
<li>下一行  [+]</li>
<li>上一行  [-]</li>
</ul>
<h3 id="关机细节"><a href="#关机细节" class="headerlink" title="关机细节"></a>关机细节</h3><p>sync命令：把内存的数据同步到磁盘</p>
<p>无论是重启还是关闭系统，首先要运行sync命令。尽管目前的shutdown&#x2F;reboot&#x2F;halt等命令均在关机前进行了sync，但小心起见，输一下sync以防万一。</p>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><ul>
<li><p>添加用户：</p>
<p><strong>useradd  用户名</strong></p>
<p>用户创建成功后会自动创建与用户名同名目录保存在&#x2F;home目录下。也可以通过__useradd -d  指定目录  新的用户名__给新创建的用户指定家目录。</p>
</li>
<li><p>修改密码  <strong>passwd 用户名</strong></p>
</li>
<li><p>删除用户</p>
</li>
</ul>
<p>​       用户的删除操作有两种，保留用户主目录的删除和不保留用户主目录的删除。</p>
<p>​	   <strong>userdel  -r 用户名</strong>   	&#x2F;&#x2F;连带用户主目录一起删除</p>
<p>​	   <strong>userdel  用户名</strong>		  &#x2F;&#x2F;只删除用户但保留用户主目录</p>
<ul>
<li>显示当前用户所在的目录 <strong>pwd</strong></li>
<li>查询用户信息 <strong>id</strong></li>
<li>切换用户 <strong>su</strong></li>
<li>查看当前用户 <strong>whoami</strong>   <strong>who am i</strong>     显示的是登录的用户，用su切换用户依旧显示登录的用户信息</li>
<li>用户组</li>
</ul>
<p>​	   新增组 <strong>groupadd 组名</strong></p>
<p>​	   删除组 <strong>groupdel  组名</strong></p>
<p>​	   添加用户时进组  <strong>useradd -g 用户组 用户名</strong></p>
<p>​	   默认添加到用户名同名组</p>
<p>​       修改用户的组 	<strong>usermod -g 用户组 用户名</strong></p>
<ul>
<li><p>用户和组相关文件：</p>
<p>&#x2F;etc&#x2F;passwd 用户配置文件	</p>
<p>&#x2F;etc&#x2F;shadow  口令配置文件</p>
<p>&#x2F;etc&#x2F;group 	组配置文件</p>
</li>
</ul>
<h3 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h3><p>0：关机</p>
<p>1：单用户 （找回丢失密码）</p>
<p>2：多用户状态没有网络服务</p>
<p>3：多用户状态有网络服务</p>
<p>4：系统未使用保留给用户</p>
<p>5：图形界面</p>
<p>6：系统重启</p>
<p>init 指令切换</p>
<h3 id="文件目录操作"><a href="#文件目录操作" class="headerlink" title="文件目录操作"></a>文件目录操作</h3><ul>
<li><p><strong>ls</strong> </p>
</li>
<li><p>-a : 显示当前目录所有的文件和目录，包含隐藏文件</p>
</li>
<li><p>-l : 以列表的方式显示信息</p>
</li>
<li><p><strong>cd</strong> </p>
<ul>
<li>cd ~ 回到用户目录 如果当前是yestin用户，执行命令后pwd查看当前目录结果是 &#x2F;home&#x2F;yestin </li>
<li>cd.. 返回上一级目录</li>
</ul>
</li>
<li><p><strong>mkdir</strong> 创建目录</p>
<ul>
<li>-p 创建多级目录    mkdir -p &#x2F;home&#x2F;film&#x2F;FreeGuy   home目录下创建了film目录，film目录下创建了FreeGuy目录。</li>
</ul>
</li>
<li><p><strong>rmdir</strong> 删除空目录</p>
</li>
</ul>
<p>​		rmdir默认删除空目录，如果要删除非空目录，需要使用 rm-rf   其中-r表示递归删除，-f表示强制删除不提示</p>
<ul>
<li>__touch__创建空文件</li>
</ul>
<p>​		如 touch hello.txt</p>
<ul>
<li><p><strong>cp</strong> 拷贝文件到指定目录</p>
<ul>
<li>-r 递归复制整个文件夹</li>
<li>遇见是否覆盖问题，可以通过\cp取消(y&#x2F;n)的频繁输入</li>
</ul>
</li>
<li><p><strong>mv</strong>   移动文件（不同的文件目录下的操作）重命名（同一个文件目录下的操作）</p>
</li>
<li><p><strong>cat</strong>   查看文件内容  之查看不修改  -n显示行号</p>
</li>
<li><p><strong>more</strong> 和  <strong>less</strong> 命令</p>
<ul>
<li><p>more命令是一个基于VI编辑器的文本过滤器，以全屏的方式按页显示文本文件的内容。</p>
</li>
<li><p>less命令用来分屏擦好看文本的内容，它的功能与more命令类似。但是比more命令更强大，支持各种显示终端。它并不是一次性将整个文件加载后才显示，而是根据显示需要加载的内容。对于显示大型文件具有较高的效率。</p>
<p>&#x2F;字串 向下搜寻	 n:向下查找    N:向上查找</p>
<p>?字串 向上搜寻	 n:向上查找    N:向下查找</p>
</li>
</ul>
</li>
<li><p><strong>echo</strong> 输出内容到控制台</p>
</li>
<li><p><strong>head</strong> 显示文件的开头内容（默认前10行）</p>
</li>
</ul>
<p>​		更改显示行数  -n 行数</p>
<ul>
<li><strong>tail</strong>  显示文件尾部内容 细节同head</li>
</ul>
<p>​	-f 实时追踪该文档的所有更新</p>
<ul>
<li>&gt; 输出重定向 （覆盖原有内容）			&gt;&gt;追加<ul>
<li>ls  -l &gt;文件   列表的内容写入文件</li>
<li>ls  -l &gt;&gt;文件   列表的内容追加写入文件</li>
<li>cat 文件1&gt;文件2    将文件1覆盖写到文件2</li>
<li>echo “内容”&gt;&gt;文件   内容追加写到文件中</li>
</ul>
</li>
<li><strong>ln</strong>       建立软链接</li>
</ul>
<p>​		如 ln -s &#x2F;root &#x2F;home&#x2F;link   link为指向&#x2F;root的软链接  </p>
<p>​		cd link 表面上是进入了link目录，实际上是进入到了&#x2F;root</p>
<p>​		删除软连接  rm &#x2F;home&#x2F;link</p>
<ul>
<li><strong>history</strong> 查看历史命令</li>
</ul>
<h3 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h3><ul>
<li><strong>date</strong>  显示当前日期</li>
</ul>
<p>​	date + ………..</p>
<p>​	%Y%m%d%H%M%S  年月日时分秒 (区分大小写), 如果需要加空格加双引号  </p>
<p>​	date -s “时间”  修改时间</p>
<h3 id="搜索查找"><a href="#搜索查找" class="headerlink" title="搜索查找"></a>搜索查找</h3><ul>
<li><p><strong>find</strong>   从指定目录向下递归遍历其各个子目录，将满足条件的文件或者目录显示在终端</p>
<p>find[搜索范围][选项]</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-name&lt;查询方式&gt;</td>
<td>按照指定的文件名查找模式查找文件</td>
</tr>
<tr>
<td>-user&lt;用户名&gt;</td>
<td>查找属于指定用户名所有文件</td>
</tr>
<tr>
<td>-size&lt;文件大小 &gt;</td>
<td>按照指定的文件大小查找文件 +[文件大小] 大于 -[]小于 []等于</td>
</tr>
</tbody></table>
</li>
<li><p><strong>locate</strong> 快速定位文件路径。 locate不遍历整个文件系统，利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件</p>
</li>
</ul>
<p>​		第一次运行前必须使用updatedb创建locate数据库</p>
<ul>
<li><p><strong>which</strong> 检索命令所在目录</p>
</li>
<li><p>__grep __ 过滤查找  </p>
<p>通常和管道符”|”一起使用，”|”表示将前一个命令的处理结果输出传递给后面的命令处理。</p>
<ul>
<li>-n 显示匹配的行号</li>
<li>-i  忽略字母大小写</li>
</ul>
</li>
</ul>
<blockquote>
<p>请在hello.txt 文件中查找”yes”所在行，并显示行号</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> hello.txt |grep -n <span class="string">&quot;yes&quot;</span></span><br><span class="line">grep -n <span class="string">&quot;yes&quot;</span> hello.txt</span><br></pre></td></tr></table></figure>

<h3 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h3><ul>
<li><p><strong>gzip</strong> 压缩	<strong>gunzip</strong> 解压(解压和压缩后不会创建源文件副本)</p>
</li>
<li><p><strong>zip</strong>&#x2F;<strong>unzip</strong></p>
<ul>
<li><p>zip -r 递归压缩，压缩目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip -r myhome.zip /home/  [将home目录及其包含的文件和子文件压缩到myhome.zip中]</span><br></pre></td></tr></table></figure>
</li>
<li><p>unzip -d &lt;dir&gt;  指定解压后文件的存放目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip -d /root /home/myhome.zip  [将myhome.zip解压到/root下]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>tar</strong> 打包&amp;解压</p>
</li>
</ul>
<p>​		打包的文件是.tar.gz后缀</p>
<p>​		tar [选项] XXX.tar.gz 打包的内容</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>产生.tar打包文件</td>
</tr>
<tr>
<td>-v</td>
<td>显示详细信息</td>
</tr>
<tr>
<td>-f</td>
<td>指定压缩后的文件名</td>
</tr>
<tr>
<td>-z</td>
<td>打包同时压缩</td>
</tr>
<tr>
<td>-x</td>
<td>解包.tar 文件</td>
</tr>
</tbody></table>
<p>案例演示</p>
<blockquote>
<p>压缩多个文件，将&#x2F;home&#x2F;pig.txt 和 &#x2F;home&#x2F;cat.txt 压缩成 animal.tar.gz</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zcvf animal.tar.gz /home/pig.txt /home/cat.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将 animal.tar.gz 解压到当前文件目录下</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf animal.tar.gz</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将animal.tar.gz 解压到&#x2F;opt&#x2F;test文件目录下</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf /home/animal.tar.gz -C /opt/test</span><br></pre></td></tr></table></figure>

<h3 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h3><ul>
<li>组操作</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td><strong>groupadd</strong></td>
<td>组创建</td>
<td align="left"></td>
</tr>
<tr>
<td><strong>chgrp</strong></td>
<td>修改文件所在组</td>
<td align="left">chgrp 组名 文件名</td>
</tr>
<tr>
<td><strong>usermod</strong></td>
<td>修改用户所在组</td>
<td align="left">usermod -g  改变用户所在组                                                              usermod-d  改变用户登录的初始目录</td>
</tr>
</tbody></table>
<h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><ul>
<li>权限说明</li>
</ul>
<blockquote>
<p>drwxr-xr-x. 2 root root		6  </p>
</blockquote>
<p>说明 </p>
<p>(对应文件：[<strong>r</strong>] 可读 [<strong>w</strong>]可写 [<strong>x</strong>]可执行</p>
<p> 对应目录：[<strong>r</strong>] 可读，可查看目录内容 [<strong>w</strong>]对目录可创建删除重命名 [<strong>x</strong>]可进入该目录</p>
<p> r&#x3D;4,w&#x3D;2,x&#x3D;1		)</p>
<ol>
<li><strong><span style='background:yellow'>d</span>spanrwxr-xr-x. 2 root root		6</strong></li>
</ol>
<p>  	</p>
<p>​	   文件类型(d,-,l,c,b)  l:链接	d:目录 	c:字符设备文件	b:块设备</p>
<ol start="2">
<li><p><strong>d<span style='background:yellow'>rwx</span>r-xr-x. 2 root root		6</strong>  	</p>
<p>该文件所有者拥有的权限</p>
</li>
<li><p>__drwx<span style='background:yellow'>r-x</span>r-x. 2 root root		6 __</p>
</li>
</ol>
<p>	</p>
<p>​		该文件所属组拥有的权限</p>
<ol start="4">
<li>__drwxr-x<span style='background:yellow'>r-x</span>. 2 root root		6 __</li>
</ol>
<p>	</p>
<p>​		其他用户拥有该文件的权限</p>
<ol start="5">
<li>__drwxr-xr-x. <span style='background:yellow'> 2 root root		6</span> __</li>
</ol>
<p>	</p>
<p>​		2			 文件：硬连接数 	目录：子目录数</p>
<p>​		root		用户</p>
<p>​		root		组</p>
<p>​		6			 文件大小（单位：字节）</p>
<ul>
<li><strong>chmod</strong>   修改权限 (u:所有者 g:所有组 o:其他人 a:所有用户	r&#x3D;4,w&#x3D;2,x&#x3D;1)</li>
</ul>
<blockquote>
<p>给test.txt的所有者rwx权限，所在组rx权限，其他组r权限</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u=rwx,g=rx,o=x test.txt    //法一</span><br><span class="line"><span class="built_in">chmod</span> 751 test.txt 	 //法二 以下两个示例也可用这种方式写</span><br></pre></td></tr></table></figure>

<blockquote>
<p>给test.txt的所有者除去执行权限，增加组w权限</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u-x,g+w test.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>给test.txt的所有用户添加r权限</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> a+r test.txt</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>chown</strong> 修改文件所有者</li>
</ul>
<p>​	<strong>chown newowner 文件&#x2F;目录</strong> 改变所有者</p>
<p>​    <strong>chown newowner:newgroup 文件&#x2F;目录</strong> 改变所有者和所有组</p>
<p>​	<strong>-R</strong> 如果是目录 则使其下所有子文件或者目录递归生效</p>
]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础操作（下）</title>
    <url>/2023/01/24/Linux%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C2/</url>
    <content><![CDATA[<h3 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h3><ul>
<li><strong>crontab</strong>  定时任务设置</li>
</ul>
<p>​		-e   	编辑crontab定时任务</p>
<p>​        -l		查询crontab任务	</p>
<p>​	    -r		删除当前用户所有的crontab任务 </p>
<span id="more"></span>

<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><ul>
<li>对新增加的硬盘sdb分区</li>
</ul>
<p>​		分区命令 <strong>fdisk</strong>  &#x2F;dev&#x2F;sdb</p>
<p>​		m 显示命令列表	p 显示磁盘分区	n 新增分区	d 删除分区	w 写入并退出</p>
<ul>
<li>格式化</li>
</ul>
<p>​		分区后输入 <strong>lsblk -f</strong>  命令可以发现sdb下已有了新的分区，但没有UUID，说明并未格式化</p>
<p>​		格式化操作  <strong>mkfs -t ext4 &#x2F;dev&#x2F;sdb1</strong></p>
<p>​		再次输入 <strong>lsblk -f</strong> 后便发现sdb下的新分区已有了UUID</p>
<ul>
<li><p>挂载	</p>
<p>作为挂载点的目录理论上为空目录。如果不是空目录，挂在后源目录的文件都会被隐藏，直到新分区被卸载原内容才会再次跑出来。</p>
<p>单一目录不应该重复挂载多个文件系统</p>
<p>单一文件系统不应该被重复挂载在不同的挂载点上</p>
<p>挂载命令 <strong>mount</strong></p>
<p>卸载命令 <strong>umount</strong></p>
<p><font color='red'>注</font> 用命令行挂载重启后会失效</p>
</li>
</ul>
<p>​	   <span style='background:yellow'>永久挂载:</span>  通过修改 &#x2F;etc&#x2F;fstab实现挂载，添加完成后执行 <strong>mount -a</strong> 即刻生效</p>
<p>​	</p>
]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
  </entry>
  <entry>
    <title>Free Guy</title>
    <url>/2023/01/20/free%20guy/</url>
    <content><![CDATA[<p>Guy (Reynolds) is a teller in a bank which is consistently robbed, and he wears the same outfit every day and orders the same coffee. Guy chums with the bank security guard Buddy(Lil Rel Howery). Unaware of his repeated day-by-day,  Guy seemly has a positive mindset for experiencing robbery multiple times a day. However, this relentlessly upbeat guy and Buddy crouch on the floor during every robbery at the bank counter and talk easily. They talk about topics from fantasy women to activities after work. It is so funny that this scene can never be associated with a robbery scene. “This is no good days here, only great ones” this is Guy’s pet phrase.</p>
<span id="more"></span>

<p>Though content, he admires the men in sunglasses who are the casual players and kinds of publicity streamers. Everything has been changed when he ran into Molotov girl(Jodie Comer, “Killing Eve”). The girl in the free city is called Millie. She is one of the programmers designing this game’s core algorithm in the real world. However, Antwan, the owner of the “free city” game company, has stolen this algorithm. So Millie has to play this game to find some evidence to back it up. And then she meets this game’s NPC–Guy, and this exciting story enters into the prelude to the climax.<br>As the story unfolds,  we can obviously tell the love between Millie and Guy, even kiss mutually. And I am astonished that Jodie Comer portrayed Moolotovgilr in the real world and Millie in the digital world, for these two figures has a significant discrepancy.<br>Even if Guy is the most optimistic, there are moments of confusion. He was told that his world is false; nay, everyone and everything in his world is false. He was unbridledly angry. He was shouting in the road, shouting to the girl complimenting the world, “Wow. Life in the big city. Ain’t nothing like it.”, “Until it crushes your soul.” When facing the old lady, Guy wasn’t impolite anymore, “No, Phyllis, I haven’t seen them. But here’s a revolutionary idea…Close your goddamn door. It’s not like they’re climbing on top of one another, forming a little kitty tower, and then jimmying the locks. They don’t have thumbs, Phyllis.”. Hysteria broke out, “None of this matters! None of it! It’s fake! We don’t matter!” Then a car hit him, and officer Johnny was passing by; ironically, when he got up, he said hello to the officer and got a response, “Have a good one, Guy.”<br>Guy visited his best friend Buddy, asking him what if you are not real. Buddy’s response comfort Guy’s mind.”Right here, right now, this moment is real.”<br>This was somehow a philosophical reflection. Actually, this plot has invoked my thinking on life. What if our world is false? If everything we do is just in a realistic game, the players know they are players. And if it is true, that will be a catastrophe because I didn’t realise I was a player. Sometimes human beings think too highly of themselves, seeking the best consistently, say, always thinking of themselves as the leading actors; when they are told that they are just NPCs, they might be disappointed. Indeed it doesn’t mean that NPCs can not live, look at Guy and buddy or someone else. They also can live happily, saving their world in their own way. Life is a span of countless difficulties, and we need to adjust our outlook, calm down, and easily live.</p>
]]></content>
      <categories>
        <category>英文影评</category>
      </categories>
      <tags>
        <tag>英语学习</tag>
      </tags>
  </entry>
  <entry>
    <title>0-1背包问题</title>
    <url>/2023/01/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p> 本文记录学习0-1背包问题时的总结，详细介绍了对背包问题的暴力解法，二维数组的思路以及滚动数组思路的理解，并给出详细注释与代码。</p>
<span id="more"></span>

<h3 id="背包问题的暴力解法"><a href="#背包问题的暴力解法" class="headerlink" title="背包问题的暴力解法"></a>背包问题的暴力解法</h3><p>​		待选物品无非是有两种状态，选与不选。背包问题求解最大价值量的问题，可以转换成遍历所有物品的各种组合，将价值与重量的总和记录在一个变量中。重量作为遍历条件，价值总量作为输出结果的一个选择。问题就回归到了回溯算法中的组合问题。力扣中39，40，216题是组合问题的经典问题，借照这些题的解法思想，背包问题的暴力解法可如下所示:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Knapsack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> pushed_weight = <span class="number">0</span>;<span class="comment">//已经装入的重量</span></span><br><span class="line">	<span class="type">int</span> pushed_cnt = <span class="number">0</span>;<span class="comment">//已经装入的数量</span></span><br><span class="line">	<span class="type">int</span> pushed_value = <span class="number">0</span>;<span class="comment">//已经装入的价值</span></span><br><span class="line">	<span class="type">int</span> max_value = <span class="number">-1</span>;<span class="comment">//记录已装入的最大价值</span></span><br><span class="line">	<span class="comment">//回溯整个背包的所有物品</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">backTrack</span><span class="params">(<span class="type">int</span> start, vector&lt;<span class="type">int</span>&gt; W, vector&lt;<span class="type">int</span>&gt; V,<span class="type">int</span> bag_w)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//start 初始遍历坐标，W记录物品重量容器,V记录物品价值容器,bag_w背包最大重量</span></span><br><span class="line">		<span class="comment">//当等于或超过背包上限或者所有物品都遍历完，则退出循环</span></span><br><span class="line">		<span class="keyword">if</span> (start&gt;=W.<span class="built_in">size</span>()||(pushed_cnt == W.<span class="built_in">size</span>() || pushed_weight == bag_w))&#123;</span><br><span class="line">			<span class="keyword">if</span> (max_value &lt; pushed_value)</span><br><span class="line">				max_value = pushed_value;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//开始回溯</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = start;i &lt; W.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pushed_weight + W[i] &lt;= bag_w) &#123;</span><br><span class="line">				pushed_weight += W[i];</span><br><span class="line">				pushed_value += V[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">backTrack</span>(i + <span class="number">1</span>, W, V, bag_w);</span><br><span class="line">            <span class="comment">//回溯完成后从背包中取出物品</span></span><br><span class="line">			pushed_weight -= W[i];</span><br><span class="line">			pushed_value -= V[i];</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="function"><span class="type">int</span> <span class="title">solving</span><span class="params">(<span class="type">int</span> start, vector&lt;<span class="type">int</span>&gt; W, vector&lt;<span class="type">int</span>&gt; V, <span class="type">int</span> bag_w)</span> </span>&#123;</span><br><span class="line">		 <span class="built_in">backTrack</span>(start, W, V, bag_w);</span><br><span class="line">		 <span class="keyword">return</span> max_value;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="comment">//创建物品容器</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; weight;<span class="comment">//物品重量</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; value;<span class="comment">//物品价值</span></span><br><span class="line">	<span class="type">bool</span> bag_continue = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (bag_continue) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;输入物品重量: &quot;</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			cin &gt;&gt; val;</span><br><span class="line">			<span class="keyword">if</span> (val &gt; <span class="number">0</span>)</span><br><span class="line">				weight.<span class="built_in">push_back</span>(val);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;输入物品价值: &quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; weight.<span class="built_in">size</span>();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; val;</span><br><span class="line">			value.<span class="built_in">push_back</span>(val);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;输入背包重量: &quot;</span>;</span><br><span class="line">		<span class="type">int</span> bag_weight;</span><br><span class="line">		cin &gt;&gt; bag_weight;</span><br><span class="line">		Knapsack res;</span><br><span class="line">		cout &lt;&lt; res.<span class="built_in">solving</span>(<span class="number">0</span>, weight, value, bag_weight) &lt;&lt; endl;</span><br><span class="line">		weight.<span class="built_in">clear</span>();</span><br><span class="line">		value.<span class="built_in">clear</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;继续下一轮？(1/0)&quot;</span>;</span><br><span class="line">		cin &gt;&gt; bag_continue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>输入物品重量: 1 3 4 -1<br>输入物品价值: 15 20 30<br>输入背包重量: 4<br>35<br>继续下一轮？(1&#x2F;0)1<br>输入物品重量: 3 1 3 4 -1<br>输入物品价值: 15 200 20 30<br>输入背包重量: 4<br>220<br>继续下一轮？(1&#x2F;0)1<br>输入物品重量: 2 3 4 1 5 5<br>-1<br>输入物品价值: 2 23 22 5 3 12<br>输入背包重量: 14<br>62<br>继续下一轮？(1&#x2F;0)0</p>
</blockquote>
<h3 id="二维动规数组"><a href="#二维动规数组" class="headerlink" title="二维动规数组"></a>二维动规数组</h3><p>​		如果采用动态规划的思路来求解背包问题，使用二维数组来记录过程值是比较好理解的一种方式。用dp[i][j]来表示这个数组，行号i 表示可取物品在0~i编号中选取，列号j 表示此时的背包容量，注意区分，此时这个背包容量与给定的背包容量是不同的。动态规划的思路是将最终目标分化为一个个小的目标来逼近，j所代表的背包容量即为求这些”小目标”时的背包容量。</p>
<p>​		在理解了dp数组所表示的含有后，给出如下的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Knapsack</span><span class="params">( vector&lt;<span class="type">int</span>&gt; goods_weight, vector&lt;<span class="type">int</span>&gt; goods_value,<span class="type">int</span> bag_weight)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//建立dp数组，初始化为0</span></span><br><span class="line">	<span class="comment">//dp数组横坐标i表示可选物品标号0-i,纵坐标j表示此刻的背包重量</span></span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;<span class="built_in">dp</span>(goods_weight.<span class="built_in">size</span>() , <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(bag_weight+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">	<span class="comment">//第一列为背包为0时的最大价值量，仍为0</span></span><br><span class="line">	<span class="comment">//第一行的初始化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = bag_weight;j - goods_weight[<span class="number">0</span>]&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">		dp[<span class="number">0</span>][j] = goods_value[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//理解二维dp数组的更新可以理解成列相关的更新，每次更新新的物品是，比较腾出该物品的空间放入背包后的价值量是否增加</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; goods_weight.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= bag_weight;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j &lt; goods_weight[i])dp[i][j] = dp[i<span class="number">-1</span>][j];<span class="comment">//此时背包容量容不下，此点处值为上一行的值</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;	<span class="comment">//若能容下比较选择物品加入背包和不选择该物品加入背包的价值量</span></span><br><span class="line">				dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j - goods_weight[i]] + goods_value[i], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[goods_weight.<span class="built_in">size</span>() - <span class="number">1</span>][bag_weight];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; weight = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; value = &#123; <span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span> &#125;;</span><br><span class="line">	<span class="type">int</span> bag = <span class="number">4</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">Knapsack</span>(weight, value, bag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>35</p>
</blockquote>
<h3 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h3><p>​		在写二维动态数组的时候，能明显感受到一个点处与上一个阶段的背包容量相关性很小，所以是否有一个方案，可以将二维数组压缩为一维数组？答案是有的。设dp[j]，j表示背包的不同阶段的质量，而数组值表示这一轮循环中可选物品中能组合出的最大的价值。</p>
<p>​		算法的整体思路与二维数组的方案大同小异，用一层循环遍历物品，每次循环多将一个物品纳入可考量的范畴，第二层循环是比较有新的物品加入选择范畴后价值的最大量是否发生变化。</p>
<p>​		有一点需要注意，第二层遍历背包容量时，不能从小到大遍历，因为每次有新的物品纳入选择范畴时都会加一下物品价值进行比较，并且dp数组质量大的是从质量小的推出来的，所以会出现物品价值重复累加的bug。拿一个例子：</p>
<table>
<thead>
<tr>
<th></th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody><tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody></table>
<p>​		 dp[1]&#x3D;dp[0]+15;</p>
<p>​	    dp[2]&#x3D;dp[2-1]+15;</p>
<p>​		本身dp[1]已经加了15了，dp[2]由dp[1]推出，所以在加了15的前提上又加了15，导致错误。</p>
<p>​		但是从后往前遍历就没这个问题了，在没进行价值比较时，前方的数组值要么是初始值0，要么是上个循环产生的前i-1个物品所得出的最大价值量，不会产生重复加和的错误。</p>
<p>​		另外，如果选用一维数组来解决背包问题时，必须先遍历物品在遍历背包容量，二维数组先遍历谁都可以。二维数组有充足的空间记录每个阶段的状态值；而一维数组空间有限，背包重量作为坐标充当索引后，就只能根据物品个数一层层向上迭代。</p>
<p>​		给出的代码打印出滚动数组的更新过程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Knapsack</span><span class="params">( vector&lt;<span class="type">int</span>&gt; goods_weight, vector&lt;<span class="type">int</span>&gt; goods_value,<span class="type">int</span> bag_weight)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//建立dp数组，初始化为0</span></span><br><span class="line">	<span class="type">int</span> goods_size = goods_value.<span class="built_in">size</span>();<span class="comment">//goods_size表示物品数量</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(bag_weight+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//先物品遍历</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; goods_size;i++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;轮遍历: &quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = bag_weight;j &gt;= goods_weight[i];j--) &#123;</span><br><span class="line">			dp[j] = <span class="built_in">max</span>(dp[j], dp[j - goods_weight[i]] + goods_value[i]);<span class="comment">//加入新物品与不加新物品价值量的比较</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;d[&quot;</span>&lt;&lt;j&lt;&lt;<span class="string">&quot;] = &quot;</span> &lt;&lt; dp[j] &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//输出数组迭代过程</span></span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[bag_weight];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; weight = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span> &#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; value = &#123; <span class="number">20</span>, <span class="number">15</span>, <span class="number">30</span> ,<span class="number">45</span>&#125;;</span><br><span class="line">	<span class="type">int</span> bag = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">Knapsack</span>(weight, value, bag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>第1轮遍历: d[10] &#x3D; 20 d[9] &#x3D; 20 d[8] &#x3D; 20 d[7] &#x3D; 20 d[6] &#x3D; 20 d[5] &#x3D; 20 d[4] &#x3D; 20 d[3] &#x3D; 20 d[2] &#x3D; 20 d[1] &#x3D; 20<br>第2轮遍历: d[10] &#x3D; 35 d[9] &#x3D; 35 d[8] &#x3D; 35 d[7] &#x3D; 35 d[6] &#x3D; 35 d[5] &#x3D; 35 d[4] &#x3D; 35 d[3] &#x3D; 20<br>第3轮遍历: d[10] &#x3D; 65 d[9] &#x3D; 65 d[8] &#x3D; 65 d[7] &#x3D; 50 d[6] &#x3D; 50 d[5] &#x3D; 50 d[4] &#x3D; 35<br>第4轮遍历: d[10] &#x3D; 65 d[9] &#x3D; 65 d[8] &#x3D; 65 d[7] &#x3D; 50<br>65</p>
</blockquote>
]]></content>
      <categories>
        <category>算法思想</category>
        <category>算法实现</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>当幸福来敲门</title>
    <url>/2022/04/18/%E5%BD%93%E5%B9%B8%E7%A6%8F%E6%9D%A5%E6%95%B2%E9%97%A8/</url>
    <content><![CDATA[<p>Chris Gardner bought a pile of the big device known as a “bone density scanner”. He feels like he has it made selling this device. However, things went contrary to his wishes; though these devices are marginally better than X-rays, the much higher price is not accepted by hospitals. Draw water with a sieve; Chris is bound to lift one of the scanners every day, which consumes most of his time.</p>
<span id="more"></span>

<p>Then goes the frustrating life of a failed husband and a struggling father. The devices aren’t sold well while the selling time, the penalty of illegal parking, the house rent and the taxes afflict this couple. The wife disgusts with her husband’s failure and making a decision to leave him. If you think this is the worst, that’s wrong. Life for Chris and his son becomes more difficult. But things may be starting to go in a good direction.<br>Many people harbour a view that this movie is a chicken soup, but I don’t think so. Chris has a good intellect, for he can restore a cube when the cube is just introduced into America. Without any instruction, he can figure out the tricks, that’s mean his head is good. I think Chris has the ability to achieve his talent. So the day will drop responsibility on has, will first frustrate, harasses. Chris is a diligent and prolific man. In order to save time, he makes himself drink less water to avoid toilet time. For the sake of saving time to study, he sleeps less. Before his success,<br>He and his son are suffering eviction by the landlord, sleeping in a toilet in a subway station. His son is very sensible, and a five-year-old boy can be so calm and considerable when his life comes to the worst. It is impressive. Misery experience makes him mature for his age.<br>You think your life becomes grim, and then things go unexpected; Your life is going done continually; you think your life has hit bottom now, but no, it is still sinking. That’s Chris’s life. It is my life, either. My life is not such miserable as Chris, but I am frustrated as Chris’s. One failure after another, the confidence when I am in middle school, has gone away. I try hard to get rid of the morass. It appears no harbingers of turning good. I admit that I haven’t worked extremely hard as Chris because I am not in a blind alley. I still have some routes of retreat. I try hard but not to the point of being desperate. That’s why I am lost.<br>There is a scene that touches me. Chris and his son go to the bus and slice the line; there is a man standing on the side shouting why they don’t let women first. Of course, in the moral rules, we should let ladies first. Nevertheless, only you know what you will lose when some unnecessary politeness you can’t give up. I cannot get on the bus early. For ladies, they stand. For Chris, maybe it is seldom rest time.<br>“Hey. Don’t ever let somebody tell you… You can’t do something. Not even me. Alright? You got a dream… You gotta protect it. People can’t do something themselves, and they wanna tell you you can’t do it. If you want something, get it. Period.”<br>My blood is boiling</p>
]]></content>
      <categories>
        <category>英文影评</category>
      </categories>
      <tags>
        <tag>英语学习</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树与树的遍历</title>
    <url>/2023/02/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>本文讲述树的遍历各种操作，层次遍历，前中后三种次序的遍历的迭代实现方式。其中包含力扣的相关题目。</p>
<p>开篇之前，先通过先序遍历的次序构建二叉树。(本片代码以二叉树为主，故多叉树结构暂不编写)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiTree</span> &#123;</span><br><span class="line">	<span class="type">char</span> val;</span><br><span class="line">	BiTree* left=<span class="literal">NULL</span>;</span><br><span class="line">	BiTree* right=<span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//先序创建二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTree</span><span class="params">(BiTree* &amp;root)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	cin &gt;&gt; ch;</span><br><span class="line">	<span class="keyword">if</span> (ch != <span class="string">&#x27;x&#x27;</span>) &#123;<span class="comment">//x表示为空结点</span></span><br><span class="line">		root = <span class="keyword">new</span> BiTree;</span><br><span class="line">		root-&gt;val = ch;</span><br><span class="line">		<span class="built_in">createTree</span>(root-&gt;left);</span><br><span class="line">		<span class="built_in">createTree</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> root = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h2><p>​		树的层次遍历与二叉树的层次遍历思路是一致的。先理解了二叉树的层次遍历的思路，再去理解树的层次遍历会轻松很多。层次遍历需要用到基本数据结构队列，在C++中的STL库中包含着队列的模板，如果不想再写个队列函数类在，直接用STL就可以了。</p>
<h3 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h3><p>​		二层次遍历即按照树的层次从上向下一层一层的遍历。它的基本思路是先将根结点放入队列，然后取出队列中的元素，如果元素含有孩子，孩子再放进队列，如此反复，知道再也没有元素能够放进队列为止。当然这种思路实现不了按层次划分结点。若要分清那些结点在第一层，那些在第二层，思路有两种。</p>
<p>​		第一种方法的思想是设立两个变量分别记录当前访问层的剩余元素个数和下一层中该访问的元素个数。代码与注释如代码块中所示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的层次遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hierarchicalTraversal1</span><span class="params">(BiTree* root)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;层次遍历: &quot;</span>&lt;&lt;endl;</span><br><span class="line">	queue&lt;BiTree*&gt;buff;</span><br><span class="line">	<span class="type">int</span> cur_level_size=<span class="number">0</span>;<span class="comment">//记录当前层元素个数</span></span><br><span class="line">	<span class="type">int</span> next_level_size=<span class="number">0</span>;<span class="comment">//记录下一层元素个数</span></span><br><span class="line">	<span class="keyword">if</span> (root) &#123;</span><br><span class="line">		<span class="comment">//根节点存在，则入队列，当前层元素加一</span></span><br><span class="line">		buff.<span class="built_in">push</span>(root);</span><br><span class="line">		cur_level_size++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!buff.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="comment">//队首结点出队，当前层结点数-1，出队元素打印</span></span><br><span class="line">		BiTree* node = buff.<span class="built_in">front</span>();</span><br><span class="line">		buff.<span class="built_in">pop</span>();</span><br><span class="line">		cout &lt;&lt; node-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		cur_level_size--;<span class="comment">//当前层元素出队操作完成，当前层结点数-1</span></span><br><span class="line">		<span class="comment">//左右孩子入队</span></span><br><span class="line">		<span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">			buff.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">			next_level_size++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">			buff.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">			next_level_size++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//一层访问完重置现场</span></span><br><span class="line">		<span class="keyword">if</span> (cur_level_size == <span class="number">0</span>) &#123;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">			cur_level_size = next_level_size;</span><br><span class="line">			next_level_size = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		第二种方法的思想非常巧妙，但整体思路是与法一一致。它在while循环里用for循环控制当前层的访问结点。思路依旧是先将根节点放进队列，再将节点的孩子放进队列，然后不断循环。不过每当一轮新的while循环时，此时的队列大小正好是当前层元素的个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树的层次遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hierarchicalTraversal2</span><span class="params">(BiTree* root)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;层次遍历: &quot;</span>&lt;&lt;endl;</span><br><span class="line">	queue&lt;BiTree*&gt;buff;</span><br><span class="line">	<span class="type">int</span> cur_level_size;<span class="comment">//记录当前层元素个数</span></span><br><span class="line">	<span class="keyword">if</span> (root)buff.<span class="built_in">push</span>(root);<span class="comment">//root不为空入队</span></span><br><span class="line">	<span class="comment">//只要队列不为空即可继续遍历</span></span><br><span class="line">	<span class="keyword">while</span> (!buff.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		cur_level_size = buff.<span class="built_in">size</span>();</span><br><span class="line">		<span class="comment">//for循环将一层的元素入队并打印</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; cur_level_size;i++) &#123;</span><br><span class="line">			BiTree* node = buff.<span class="built_in">front</span>();<span class="comment">//结点node接收队首元素</span></span><br><span class="line">			buff.<span class="built_in">pop</span>();</span><br><span class="line">			cout &lt;&lt; node-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="comment">//孩子结点入队</span></span><br><span class="line">			<span class="keyword">if</span> (node-&gt;left)buff.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">			<span class="keyword">if</span> (node-&gt;right)buff.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>力扣题目</strong></p>
<p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102. 二叉树的层序遍历 - 力扣（Leetcode）</a></p>
<h3 id="N叉树的层次遍历"><a href="#N叉树的层次遍历" class="headerlink" title="N叉树的层次遍历"></a>N叉树的层次遍历</h3><p>​		N叉树的层次遍历以力扣题429为例</p>
<p>​	   <a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历 - 力扣（Leetcode）</a></p>
<p><strong>题目描述</strong></p>
<p>给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。（即从左到右，逐层遍历）。</p>
<p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,null,3,2,4,null,5,6]</span><br><span class="line">输出：[[1],[3,2,4],[5,6]]</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>二叉树层次遍历的两种都适用，此处代码以第二种方法展示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;path;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">        <span class="keyword">using</span> n=Node*;</span><br><span class="line">        queue&lt;n&gt;que;</span><br><span class="line">        <span class="keyword">if</span>(root)que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> cur_size=que.<span class="built_in">size</span>();<span class="comment">//千万不能在for循环中i&lt;que.size(),因为for循环中que.size()动态变化</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cur_size;i++)&#123;</span><br><span class="line">                n node=que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                path.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="comment">//队列先进先出，所以正序遍历children</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;node-&gt;children.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(node-&gt;children[j])que.<span class="built_in">push</span>(node-&gt;children[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            path.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="层次遍历的刷题攻略"><a href="#层次遍历的刷题攻略" class="headerlink" title="层次遍历的刷题攻略"></a>层次遍历的刷题攻略</h3><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图 - 力扣（Leetcode）</a></p>
<p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值 - 力扣（Leetcode）</a></p>
<p><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515. 在每个树行中找最大值 - 力扣（Leetcode）</a></p>
<p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针 - 力扣（Leetcode）</a></p>
<p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II - 力扣（Leetcode）</a></p>
<h2 id="树的先序遍历"><a href="#树的先序遍历" class="headerlink" title="树的先序遍历"></a>树的先序遍历</h2><p>先序遍历依旧先从二叉树讲起，在理解二叉树的基础上，多叉树的遍历无非就是换个方式访问孩子链表而已。</p>
<h3 id="二叉树的先序遍历"><a href="#二叉树的先序遍历" class="headerlink" title="二叉树的先序遍历"></a>二叉树的先序遍历</h3><p>与层次遍历不同，二叉树的先序遍历需要用到栈的数据结构。先序遍历的顺序是<strong>根—左—右</strong>，所以根节点先输出，之后向左遍历，其次再访问右结点。这里有个细节需要注意，<strong>由于栈的特性是后进先出，在孩子结点入栈的时候，需要先将右孩子入栈，左孩子后入栈</strong>，这是因为之后要先访问左孩子导致的。当然，N叉树的遍历过程也需要注意这个细节。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历迭代实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrderTraversal</span><span class="params">(BiTree* root)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;先序遍历: &quot;</span>;</span><br><span class="line">	stack&lt;BiTree*&gt;st;</span><br><span class="line">	<span class="keyword">if</span> (root)st.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		BiTree* node = st.<span class="built_in">top</span>();<span class="comment">//取栈顶元素</span></span><br><span class="line">		st.<span class="built_in">pop</span>();<span class="comment">//栈顶元素出栈</span></span><br><span class="line">		cout &lt;&lt; node-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="comment">//将左右孩子结点加入到栈中</span></span><br><span class="line">		<span class="keyword">if</span> (node-&gt;right)st.<span class="built_in">push</span>(node-&gt;right);<span class="comment">//此处需谨慎，先右边进去左边再进去，因为下一个要先访问左边的</span></span><br><span class="line">		<span class="keyword">if</span> (node-&gt;left)st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="N叉树的先序遍历"><a href="#N叉树的先序遍历" class="headerlink" title="N叉树的先序遍历"></a>N叉树的先序遍历</h3><p><a href="https://leetcode.cn/problems/n-ary-tree-preorder-traversal/">589. N 叉树的前序遍历 - 力扣（Leetcode）</a></p>
<p><strong>题目描述</strong></p>
<p>给定一个 n 叉树的根节点 <code>root</code> ，返回 <em>其节点值的 <strong>前序遍历</strong></em> 。</p>
<p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,null,3,2,4,null,5,6]</span><br><span class="line">输出：[1,3,5,6,2,4]</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<p>整体思路与二叉树前序遍历思路一致。但在处理孩子结点时要改一改代码。而且孩子之间的顺序是从左到右访问的，所以孩子结点要从后向前入栈，即逆序入栈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> N=Node*;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recursion</span><span class="params">(N root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;root-&gt;children.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="built_in">recursion</span>(root-&gt;children[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">       <span class="built_in">recursion</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h2><p>二叉树的中序遍历思路与先序遍历思路差别很大，不要想着照着先序遍历的代码改改就能实现。中序遍历的顺序是<strong>左—根—右</strong>，路过的结点都要存到栈中，直到遍历到了空结点，此时才可以取出栈顶元素，打印输出。之后就要开始走右孩子的道路了，不然的话会原地打转。</p>
<p>另外，while循环的判定条件不能像先序遍历那样，只判定栈空不空就行了。这样会导致根节点的右半子树无法访问，因为根节点出栈的时候，根节点的右孩子还没有入栈，然而根节点必定是栈底元素，根节点一出去，栈为空，while判定条件不成立，右孩子未访问。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历迭代实现</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">InOrderTraversal</span><span class="params">(BiTree* root)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;中序遍历: &quot;</span>;</span><br><span class="line">	stack&lt;BiTree*&gt;st;</span><br><span class="line">	BiTree* cur = root;</span><br><span class="line">	<span class="keyword">while</span> (cur!=<span class="literal">NULL</span>||!st.<span class="built_in">empty</span>()) &#123;<span class="comment">//一定要加cur!=NULL，否则根节点出去后栈已经变空了，根节点的右边无法访问</span></span><br><span class="line">		<span class="comment">//遍历到非空结点一直向左遍历，找到最左边的结点</span></span><br><span class="line">		<span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			st.<span class="built_in">push</span>(cur);</span><br><span class="line">			cur = cur-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//遍历到空结点，返回栈中的上一个结点，然后向右遍历</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cur = st.<span class="built_in">top</span>();</span><br><span class="line">			st.<span class="built_in">pop</span>();</span><br><span class="line">			cout &lt;&lt; cur-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			cur = cur-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="树的后序遍历"><a href="#树的后序遍历" class="headerlink" title="树的后序遍历"></a>树的后序遍历</h2><h3 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h3><p>用迭代的思想实现二叉树的后序遍历有一个简单的方法，后序遍历是<strong>左—右—根</strong>,如果把它逆置过来，不就变成了根—右—左。这不就是将先序遍历改改代码嘛。把上文讲述的先序遍历的细节理解了，用这种方式写后序遍历不成问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序遍历的两种实现</span></span><br><span class="line"><span class="comment">//左右根-&gt;根右左的逆序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrderTraversal1</span><span class="params">(BiTree* root)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;后序遍历：&quot;</span>;</span><br><span class="line">	stack&lt;BiTree*&gt;st;</span><br><span class="line">	vector&lt;<span class="type">char</span>&gt;res;</span><br><span class="line">	<span class="keyword">if</span> (root)st.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		BiTree* node = st.<span class="built_in">top</span>();</span><br><span class="line">		st.<span class="built_in">pop</span>();</span><br><span class="line">		res.<span class="built_in">push_back</span>(node-&gt;val);<span class="comment">//将遍历结果存到容器中</span></span><br><span class="line">		<span class="keyword">if</span> (node-&gt;left)st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;right)st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());<span class="comment">//将保存结果的容器逆置即为所求</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : res)</span><br><span class="line">		cout &lt;&lt; c&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="N叉树的后序遍历"><a href="#N叉树的后序遍历" class="headerlink" title="N叉树的后序遍历"></a>N叉树的后序遍历</h3><p><a href="https://leetcode.cn/problems/n-ary-tree-postorder-traversal/">590. N 叉树的后序遍历 - 力扣（Leetcode）</a></p>
<p><strong>题目描述</strong></p>
<p>给定一个 n 叉树的根节点 <code>root</code> ，返回 <em>其节点值的 <strong>后序遍历</strong></em> 。</p>
<p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,null,3,2,4,null,5,6]</span><br><span class="line">输出：[5,6,3,2,4,1]</span><br></pre></td></tr></table></figure>

<p><strong>思路</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> n=Node*;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        stack&lt;n&gt;st;</span><br><span class="line">        <span class="keyword">if</span>(root)st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(st.<span class="built_in">size</span>())&#123;</span><br><span class="line">            n node=st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;node-&gt;children.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;children[i])</span><br><span class="line">                    st.<span class="built_in">push</span>(node-&gt;children[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="代码测试结果"><a href="#代码测试结果" class="headerlink" title="代码测试结果"></a>代码测试结果</h2><p>将上述讲述的代码做一个测试</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BiTree* root = <span class="keyword">new</span> BiTree;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;先序构建二叉树，x表示空结点，输入一个元素: &quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">createTree</span>(root);<span class="comment">//1 2 4 6 x x 7 x x 5 x x 3 x 3 x x</span></span><br><span class="line">	<span class="built_in">hierarchicalTraversal1</span>(root);<span class="comment">//层次遍历</span></span><br><span class="line">	<span class="built_in">hierarchicalTraversal2</span>(root);<span class="comment">//层次遍历</span></span><br><span class="line">	<span class="built_in">PreOrderTraversal</span>(root);<span class="comment">//先序遍历</span></span><br><span class="line">	<span class="built_in">InOrderTraversal</span>(root);<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="built_in">PostOrderTraversal1</span>(root);<span class="comment">//后序遍历</span></span><br></pre></td></tr></table></figure>



<p><strong>运行结果</strong></p>
<blockquote>
<p>先序构建二叉树，x表示空结点，输入一个元素:<br>1 2 4 6 x x 7 x x 5 x x 3 x 3 x x<br>层次遍历:<br>1<br>2 3<br>4 5 3<br>6 7<br>层次遍历:<br>1<br>2 3<br>4 5 3<br>6 7<br>先序遍历: 1 2 4 6 7 5 3 3<br>中序遍历: 6 4 7 2 5 1 3 3<br>后序遍历：6 7 4 5 2 3 3 1</p>
</blockquote>
]]></content>
      <categories>
        <category>基础数据结构与算法思想</category>
      </categories>
      <tags>
        <tag>迭代</tag>
        <tag>二叉树</tag>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11新特性</title>
    <url>/2023/02/07/C++11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p> 本文从五个方面详述C++11特性：</p>
<ul>
<li>关键字与变量的使用</li>
<li>面向对象特性(委托构造函数，继承构造函数，可调用对象包装器、邦定器，lambda表达式等)</li>
<li>移动语义</li>
<li>智能指针</li>
<li>多线程</li>
</ul>
<span id="more"></span>

<h1 id="关键字与变量的使用"><a href="#关键字与变量的使用" class="headerlink" title="关键字与变量的使用"></a>关键字与变量的使用</h1><h2 id="字符串原始字面量"><a href="#字符串原始字面量" class="headerlink" title="字符串原始字面量"></a>字符串原始字面量</h2><p>​		c++11中添加了字符串的原始字面量，定义方式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R&quot;注释(字符串)注释&quot;</span><br></pre></td></tr></table></figure>

<p>​		()两边的字符除按可以省略，程序会直接打印括号中的字符串，不会在乎类似转移字符之类。</p>
<p>如下面的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string path1 = <span class="string">&quot;\root\tmp\hello.cpp&quot;</span>;</span><br><span class="line">string path2 = <span class="string">&quot;\\root\\tmp\\hello.cpp&quot;</span>;</span><br><span class="line">string path3= <span class="string">R&quot;(\root\tmp\hello.cpp)&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;path1:&quot;</span> &lt;&lt; path1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;path2:&quot;</span> &lt;&lt; path2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;path3:&quot;</span> &lt;&lt; path3 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>ooth1:  mphello.cpp<br>path2:\root\tmp\hello.cpp<br>path3:\root\tmp\hello.cpp</p>
</blockquote>
<p>​		可能会奇怪，path1字符串输出的是什么？为什么明明是想输出path1结果输出了ooth1？原因是但斜杠与一些字母代表转义字符，\r表示回到当前行的行首，而不会换到下一行，如果接着输出的话，本行以前的内容会被逐一覆盖，\t是制表符，相当于按下一次tab键，即将”path1：“被”(\r)oot(\t)   “替换，导致出现运行结果中的现象。这种现象的解决可以像path2那种写法，出现反斜杠时在加一个反斜杠；或者像path3那种写法处理。</p>
<p>​	另外一种功能是使用了字符串的原始字面量后，字符串可以占用多行了，代码的可读性得到了改善。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">	我等了三年，</span></span><br><span class="line"><span class="string">就是要等一个机会，</span></span><br><span class="line"><span class="string">我要争一口气，</span></span><br><span class="line"><span class="string">不是证明我了不起，</span></span><br><span class="line"><span class="string">我是要告诉大家，</span></span><br><span class="line"><span class="string">我曾经失去的我一定要拿回来</span></span><br><span class="line"><span class="string">	)&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="long-long-类型"><a href="#long-long-类型" class="headerlink" title="long long 类型"></a>long long 类型</h2><p>​		long long实际上与 signed long long, long long int, signed long long int 是一回事。unsigned long long 实际上即为 unsigned long long int。在使用long long类型时，要在数据后添加LL后缀；unsigened long long后添加ULL后缀。</p>
<p>​		使用宏定义<strong>LLONG_MAX,LLong_MIN,ULLONG_MAX</strong>,分别可以表示long long数据类型的最大最小值，unsigned long long类型的最大值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;long long max:  &quot;</span> &lt;&lt; LLONG_MAX &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;long long min:  &quot;</span> &lt;&lt; LLONG_MIN &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;unsigned long long min:  &quot;</span> &lt;&lt; ULLONG_MAX &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>long long max:  9223372036854775807<br>long long min:  -9223372036854775808<br>unsigned long long min:  18446744073709551615</p>
</blockquote>
<h2 id="静态断言"><a href="#静态断言" class="headerlink" title="静态断言"></a>静态断言</h2><p>​		C++11提供了静态断言， 相比<strong>assert</strong>，静态断言不需要包含新的头文件，并且可以输出自己希望的输出信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">long</span>) == <span class="number">4</span>,<span class="string">&quot;当前机子不是64位&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;当前机子是64位&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>​		值得一提的是，静态断言中的判定表达式必须要是常量表达式。在VS环境下，程序执行之前便判断出常量表达式的真假，当常量表达式为假时，VS会提示”静态断言失败“。</p>
<h2 id="异常与noexcept"><a href="#异常与noexcept" class="headerlink" title="异常与noexcept"></a>异常与noexcept</h2><p>noexcept是C++11新增特性，相当于throw()，即不向函数外发送任何异常。</p>
<p>关于throw()的用法可查<a href="http://c.biancheng.net/view/2332.html">C++ throw（抛出异常）详解 (biancheng.net)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span><span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span><span class="comment">//括号中可以添加判定表达式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="string">&quot;来自test1的异常&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span><span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;来自test2的异常&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test3</span><span class="params">()</span><span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;来自test3的异常&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;来自test4的异常&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//test1();//程序中止</span></span><br><span class="line">        <span class="comment">//test2();//程序中止</span></span><br><span class="line">        <span class="comment">//test3();//程序中止</span></span><br><span class="line">        <span class="built_in">test4</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span> *err) &#123;</span><br><span class="line">        cout &lt;&lt; err &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>来自test4的异常<br>main结束</p>
</blockquote>
<h2 id="数值-字符串间的转换"><a href="#数值-字符串间的转换" class="headerlink" title="数值 字符串间的转换"></a>数值 字符串间的转换</h2><ul>
<li><p>数值-&gt;字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">int</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">long</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">long</span> <span class="type">long</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">unsigned</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">float</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">double</span> val)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">to_string</span> <span class="params">(<span class="type">long</span> <span class="type">double</span> val)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串-&gt;数值</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//str:待转换的字符串</span></span><br><span class="line"><span class="comment">//pos:从第几个字符的下标开始无法继续进行，比如321zangao，pos为3</span></span><br><span class="line"><span class="comment">//base: 待转换字符串的禁止，0为自动检测,注意区分最后转换后的数值为10进制</span></span><br><span class="line"><span class="function"><span class="type">int</span>       <span class="title">stoi</span><span class="params">( <span class="type">const</span> std::string&amp; str, std::<span class="type">size_t</span>* pos = <span class="number">0</span>, <span class="type">int</span> base = <span class="number">10</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span>      <span class="title">stol</span><span class="params">( <span class="type">const</span> std::string&amp; str, std::<span class="type">size_t</span>* pos = <span class="number">0</span>, <span class="type">int</span> base = <span class="number">10</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">stoll</span><span class="params">( <span class="type">const</span> std::string&amp; str, std::<span class="type">size_t</span>* pos = <span class="number">0</span>, <span class="type">int</span> base = <span class="number">10</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span>      <span class="title">stoul</span><span class="params">( <span class="type">const</span> std::string&amp; str, std::<span class="type">size_t</span>* pos = <span class="number">0</span>, <span class="type">int</span> base = <span class="number">10</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">stoull</span><span class="params">( <span class="type">const</span> std::string&amp; str, std::<span class="type">size_t</span>* pos = <span class="number">0</span>, <span class="type">int</span> base = <span class="number">10</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span>       <span class="title">stof</span><span class="params">( <span class="type">const</span> std::string&amp; str, std::<span class="type">size_t</span>* pos = <span class="number">0</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span>      <span class="title">stod</span><span class="params">( <span class="type">const</span> std::string&amp; str, std::<span class="type">size_t</span>* pos = <span class="number">0</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">stold</span><span class="params">( <span class="type">const</span> std::string&amp; str, std::<span class="type">size_t</span>* pos = <span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure>

<p>代码演示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;2022.6.23newera&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> sz&#123;&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">stoi</span>(str, &amp;sz)&lt;&lt;endl &lt;&lt; <span class="string">&quot;转换完成字符个数:&quot;</span> &lt;&lt; sz &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">stoi</span>(str, &amp;sz,<span class="number">16</span>)&lt;&lt;endl &lt;&lt; <span class="string">&quot;转换完成字符个数:&quot;</span> &lt;&lt; sz &lt;&lt; endl;<span class="comment">//将其中的数值看成16进制进行转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>2022<br>转换完成字符个数:4<br>8226<br>转换完成字符个数:4</p>
</blockquote>
<ul>
<li>更快的转换方式</li>
</ul>
<p>​		&lt;sstream&gt; 主要用来进行数据类型转换，由于&lt;sstream&gt; 使用 string 对象来代替字符数组（snprintf 方式），避免了缓冲区溢出的危险；而且，因为传入参数和目标对象的类型会被自动推导出来，所以不存在错误的格式化符号的问题。简单说，相比 C 编程语言库的数据类型转换，&lt;sstream&gt; 更加安全、自动和直接。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stringstream stream;</span><br><span class="line">    string str = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">    <span class="type">int</span> dig = <span class="number">12345</span>;</span><br><span class="line">    <span class="comment">//设置两个存放结果的变量</span></span><br><span class="line">    <span class="type">int</span> dig_res;</span><br><span class="line">    string str_res;</span><br><span class="line">    <span class="comment">//数2字符串</span></span><br><span class="line">    stream &lt;&lt; str;</span><br><span class="line">    stream &gt;&gt; dig_res;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;数字转成的字符串：&quot;</span> &lt;&lt; dig_res &lt;&lt; endl;</span><br><span class="line">    stream.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="comment">//字符串2数</span></span><br><span class="line">    stream &lt;&lt; dig;</span><br><span class="line">    stream &gt;&gt; str_res;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串转成的数字：&quot;</span> &lt;&lt; str_res &lt;&lt; endl;</span><br><span class="line">    stream.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自动类型推导"><a href="#自动类型推导" class="headerlink" title="自动类型推导"></a>自动类型推导</h2><h3 id="auto自动推导"><a href="#auto自动推导" class="headerlink" title="auto自动推导"></a>auto自动推导</h3><p>​		auto能自动推导变量的类型，但使用auto自动类型推导必须给变量初始化，不然无法推导。auto可以与指针、引用结合，也可以与const、volatile限定符配合使用。只有当变量是指针或者引用类型时，推导结果才会保留const，volatile关键字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> animal = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">auto</span> cat = animal;<span class="comment">//cat推导为int类型, auto对应int</span></span><br><span class="line"><span class="keyword">auto</span> dog;<span class="comment">//dog未被初始化, 不能被自动推导 **语法错误**</span></span><br><span class="line"><span class="keyword">auto</span>* pet = &amp;animal;<span class="comment">//pet推导为int*, auto对应int</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> pig = animal;<span class="comment">//pig为const int类型，auto对应int</span></span><br><span class="line"><span class="keyword">auto</span> duck = pig;<span class="comment">//duck为int类型 **pig是const int，但duck没有指针或引用，所以不保留const**</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; horse = animal;<span class="comment">//horse为const int类型</span></span><br><span class="line"><span class="keyword">auto</span>&amp; mouse = animal;<span class="comment">//mouse为int&amp;类型</span></span><br></pre></td></tr></table></figure>

<p>​		auto一般适用于替代迭代器的定义和泛型编程中。</p>
<ul>
<li>如果变量的定义太冗长，可以用auto替代</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;val&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	<span class="keyword">auto</span> it = val.<span class="built_in">begin</span>();<span class="comment">//vector&lt;int&gt;::iterator it,简化了很多</span></span><br><span class="line">	<span class="keyword">for</span> (;it != val.<span class="built_in">end</span>();it++)</span><br><span class="line">		cout &lt;&lt; *it;</span><br></pre></td></tr></table></figure>

<ul>
<li>在泛型编程中，如果要接收一个模板变量，是很难确定变量的类型，所以用什么数据类型接收就是一件非常头疼的事。解决这个问题，不仅要在模板声明中添加多个变量，在模板函数调用中还要多写多个参数。但如果有了auto关键字，就迎刃而解了。只需将不确定类型的变量用auto接收即可完成任务。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">P</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">test1</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">	P res = val;<span class="comment">//不仅要添一个class P，调用时也要多传一个参数。</span></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">test2</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> res = val;<span class="comment">//auto 定义res省去了很多工程</span></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">test1</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">2</span>);</span><br><span class="line">	cout &lt;&lt; <span class="built_in">test2</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="auto的限制"><a href="#auto的限制" class="headerlink" title="auto的限制"></a>auto的限制</h3><ul>
<li>不能在函数参数中使用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="keyword">auto</span> a)</span></span>&#123; <span class="comment">//*错误*</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不能用于初始化类的非静态成员变量</li>
</ul>
<p>​		又因为静态非常量成员不能在类内初始化，所以在类内auto只能修饰静态常量成员</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">auto</span> a = <span class="number">-1</span>;	<span class="comment">//	*错误*</span></span><br><span class="line">	<span class="type">static</span> <span class="keyword">auto</span> b = <span class="number">-1</span>;	<span class="comment">//	*错误* 静态非常量要在类外初始化</span></span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="keyword">auto</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不能定义数组</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> suss=arr;<span class="comment">//正确，arr1为int*类型</span></span><br><span class="line"><span class="keyword">auto</span> err1[]=arr;<span class="comment">// *错误*</span></span><br><span class="line"><span class="keyword">auto</span> err2[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">// *错误*</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不能当作模板参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">test</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">test</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>);<span class="comment">//正确</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">test</span>&lt;<span class="keyword">auto</span>&gt;(<span class="number">2</span>);<span class="comment">// *错误*</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p><strong>语法格式</strong>：decltype(表达式)</p>
<p>在变量类型不确定又不想声明的情况下可以用到decltype。decltype对变量类型的推导是在编译期完成的，只用于表达式类型的推导而不计算表达式的值。</p>
<p><strong>推导规则</strong></p>
<ul>
<li><p>表达式为变量，推导得到的类型与变量类型一致</p>
</li>
<li><p>表达式为函数，推导得出的类型与函数返回值一致</p>
</li>
</ul>
<p>​		如果const修饰的是纯右值（纯数据）时，const不会保留，比如const int类型会推导成int。</p>
<ul>
<li>左值表达式或者被括号修饰，推导结果为表达式类型的引用，如果有const、volatile是不能省略的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//括号修饰</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> const_int = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> normal_int = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>((const_int)) v1= <span class="number">3</span>;<span class="comment">//const int&amp; v1</span></span><br><span class="line"><span class="keyword">decltype</span>((normal_int)) v2= normal_int;<span class="comment">//int&amp; v2 </span></span><br><span class="line"><span class="comment">//表达式修饰</span></span><br><span class="line"><span class="type">int</span> m = <span class="number">1</span>, n = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(m+n) v3 = <span class="number">3</span>;<span class="comment">//int v3  m+n是右值</span></span><br><span class="line"><span class="keyword">decltype</span>(n=m+n) v4 = normal_int;<span class="comment">//int&amp; v4	左值表达式推导结果为引用</span></span><br></pre></td></tr></table></figure>

<p>decltype同auto一样，广泛应用于泛型编程中。比如说，写了个类模板，里面用到了容器，想用迭代器遍历容器中的数据，迭代器如何定义？如果用 T::iterator it; 之类的语法是错误的，因为编译器无法识别。最好的方案就是用decltype类型推导。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (it = c.<span class="built_in">begin</span>(); it != c.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//T::iterator it;// *错误* 这里不能确定迭代器类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">T</span>().<span class="built_in">begin</span>()) it;</span><br><span class="line">&#125;;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>总结一下，auto的使用必须初始化，decltype可以不用初始化。</p>
<h3 id="融合！返回值类型后置"><a href="#融合！返回值类型后置" class="headerlink" title="融合！返回值类型后置"></a>融合！返回值类型后置</h3><p>上述文章阐述了auto和decltype的用法，此处讲解一个两者结合的使用方法。</p>
<p>在设计模板函数或者模板类的时候，难免会出现模板变量类型不一样的情况。加入需要两个数值类型的加和运算的模板函数，返回两者的加和。我们知道数值类型有很多，short，int，float，double，long等等，甚至字符变量也能掺和掺和。不同的组合的返回类型也是不同的，但在设计模板函数时在一开头就要给出返回类型，在没有确定参数类型时给出返回类型似乎是一件不可能的事情，C++14中编译器才可以自己推导任何函数的返回类型，如果C++11的编译器用auto做函数返回类型是错误的，因为没有初始化。所以就想到了decltype，然而decltype的使用需要知道传递的参数，如果这么写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(t+u) <span class="built_in">add</span>(T t, U u)</span><br></pre></td></tr></table></figure>

<p>肯定是错误的，因为decltype中的t和u还没给出，编译器无法识别直接报错。如果能让返回类型放在参数列表之后定义就好了。所以便有了下述的代码思路</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add0</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t+u)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是返回值类型后置。</p>
<h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><h3 id="C-11列表初始化新玩法"><a href="#C-11列表初始化新玩法" class="headerlink" title="C++11列表初始化新玩法"></a>C++11列表初始化新玩法</h3><p>c++11标准中，可以通过{ }直接初始化对象，之前标准{}前需要一个’&#x3D;’。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> old_standard[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> new_standard[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>使用new 操作符创建新对象时也可以使用列表初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* new_point = <span class="keyword">new</span> <span class="type">int</span>&#123; <span class="number">1024</span> &#125;;</span><br><span class="line"><span class="type">int</span>* new_array = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>]&#123; <span class="number">1024</span>,<span class="number">2048</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>return的返回值也可以返回一个匿名对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123; <span class="number">1</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> val=<span class="built_in">test</span>();</span><br><span class="line">cout &lt;&lt; val;<span class="comment">//val=1</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义类型的初始化"><a href="#自定义类型的初始化" class="headerlink" title="自定义类型的初始化"></a>自定义类型的初始化</h3><p>在初始化以下类时需要注意</p>
<ul>
<li>若自定义类型中有私有成员，无法使用初始化列表初始化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T1</span> &#123;<span class="comment">//不可用初始化列表初始化</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> v;</span><br><span class="line">&#125;t1&#123;<span class="number">1</span>&#125;;<span class="comment">//错误</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T2</span>&#123;<span class="comment">//不可用初始化列表初始化</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">&#125;t2&#123;<span class="number">1</span>&#125;;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>但这样是可以的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> v;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T3</span>&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	T t;</span><br><span class="line">&#125;t3&#123; <span class="number">2</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;t3.x= &quot;</span> &lt;&lt; t3.x &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;t3.t.x= &quot;</span> &lt;&lt; t3.t.x &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>t3.x&#x3D; 2<br>t3.t.x&#x3D; 1</p>
</blockquote>
<ul>
<li>类中有非静态成员可以通过列表初始化进行初始化，但不能初始化静态成员变量</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T4</span>&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s;</span><br><span class="line">&#125;t4&#123; <span class="number">2</span> &#125;;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<ul>
<li>c++14之前不支持用列表初始化的方式初始化包含已有初始化的非静态变量的结构体\类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T5</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> z[<span class="number">3</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">&#125;t5&#123;<span class="number">520</span>, <span class="number">13.14</span>, &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;<span class="comment">//c++11不支持,c++14后支持</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果有构造函数能初始化自定义类型中的变量，那么也可以使用列表初始化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T6</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="built_in">T6</span>(<span class="type">int</span> a, <span class="type">int</span> b):<span class="built_in">x</span>(a), <span class="built_in">v</span>(b) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> v;</span><br><span class="line">&#125;t6&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;<span class="comment">//正确</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="std-initializer-list"><a href="#std-initializer-list" class="headerlink" title="std::initializer_list"></a>std::initializer_list</h3><p>如果想要自定义一个函数并且接收任意个数的参数，只需要将函数参数指定为 std::initializer_list，使用初始化列表 { } 作为实参进行数据传递即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(initializer_list&lt;<span class="type">int</span>&gt; list)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;);</span><br></pre></td></tr></table></figure>



<h2 id="using"><a href="#using" class="headerlink" title="using"></a>using</h2><h3 id="引子：typedef-和-函数指针"><a href="#引子：typedef-和-函数指针" class="headerlink" title="引子：typedef 和 函数指针"></a>引子：typedef 和 函数指针</h3><ul>
<li>函数指针</li>
</ul>
<p>​		顾名思义，函数指针就是指向函数地址的变量。函数指针的使用往往会和指针函数混淆。在C++规则中，括号优先级是大于*优先级的，所以表达式**关键字(*函数名)**表达就是一个指针类型。下面拿int类型设计一个指针函数和一个函数指针加以区分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func1</span><span class="params">(<span class="type">int</span> val)</span></span>;<span class="comment">//指针函数</span></span><br><span class="line"><span class="built_in">int</span>(*func2) (<span class="type">int</span> val);<span class="comment">//函数指针</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>typedef</p>
<p><strong>typedef</strong>用于给变量起别名，增加代码的可读性。最基本的用法就如以下代码所示。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> type_int; <span class="comment">//type_int相当于int的别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> *type_int_p;<span class="comment">//type_int_p相当于int*的别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123; type_int x; &#125; type_struct;<span class="comment">//type_struct相当于该结构体的别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> type_array[] ;<span class="comment">//type_array相当于整型数组的别名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	type_int a = <span class="number">2</span>;</span><br><span class="line">	type_int_p p = &amp;a;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;a= &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p= &quot;</span> &lt;&lt; p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>a&#x3D; 2<br>p&#x3D; 0000006D208FF764</p>
</blockquote>
<p>​		另外，定义新类型时添加括号并不是语法错误，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type_array</span>(arr) = &#123; <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;<span class="comment">//定义了一个数组，数组内容为&#123;2,3,4&#125;</span></span><br></pre></td></tr></table></figure>

<p>​		接下来看看这种形式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">int</span> <span class="title">nickname</span><span class="params">(<span class="type">int</span>,string)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​		它的作用相当于给返回类型为<code>int</code>，含一个<code>int</code>类型和一个<code>string</code>类型的参数的函数起了别名<code>nickname</code>。下面的一段程序将演示它的使用方式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">int</span> <span class="title">nickname</span><span class="params">(<span class="type">int</span>,string)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*_nickname)</span><span class="params">(<span class="type">int</span>,string)</span></span>;</span><br><span class="line"><span class="built_in">nickname</span>(CallMeRealName);<span class="comment">//相当于函数定义 int CallMeRealName(int id, string name);</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	_nickname func1;</span><br><span class="line">	func1 = CallMeRealName;<span class="comment">//func1相当于CallMeRealName函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;id 为&quot;</span> &lt;&lt; <span class="built_in">func1</span>(<span class="number">702</span>, <span class="string">&quot;詹姆斯&quot;</span>);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CallMeRealName</span><span class="params">(<span class="type">int</span> id, string name)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;我叫&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; ！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		为了可读性，更多的用typedef给函数指针起别名，这样在编程过程中能将原来的函数名修改成一个应景的名字，增加可读性。而对普通函数起别名多用于在函数定义的过程中。</p>
<h3 id="using-的使用"><a href="#using-的使用" class="headerlink" title="using 的使用"></a>using 的使用</h3><p>​		<code>using</code>的基本使用方法跟typedef大同小异，就不详述了。区别是using习惯于用赋值的方式定义变量的新名称。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> type_int = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> nickname = <span class="built_in">int</span>(*)(<span class="type">int</span>, string);<span class="comment">//函数指针的声明</span></span><br></pre></td></tr></table></figure>

<p>​		using相比于typedef有什么优势呢？下面举一个用typedef给模板取别名的例子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;T&gt;typedef_vector;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>​		类似语句编译器会提示” 此处不能指定typedef “，如果想用typedef指定模板，需要用一个类或者结构体将模板包含进去。像这样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyVec</span> &#123;</span><br><span class="line">	<span class="keyword">typedef</span> vector&lt;T&gt;typedef_vector;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​		但是用using的方式的话就会简单很多，不需要先建立结构体或者类，直接定义即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">using</span> using_vector = vector&lt;T&gt;;</span><br></pre></td></tr></table></figure>

<p>​		之后在看一看在初始化的区别, 先定义了一个仿函数<code>Myprint</code>，用于打印输出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myprint</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyVec&lt;string&gt;::typedef_vector test1 = &#123; <span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;赵六&quot;</span> &#125;;<span class="comment">//typedef</span></span><br><span class="line">using_vector &lt;string&gt;test2 = &#123; <span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;赵六&quot;</span> &#125;;<span class="comment">//using </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;typedef：&quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(test1.<span class="built_in">begin</span>(), test1.<span class="built_in">end</span>(),<span class="built_in">Myprint</span>&lt;string&gt;());</span><br><span class="line">cout &lt;&lt; endl&lt;&lt;<span class="string">&quot;using：&quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(test2.<span class="built_in">begin</span>(), test2.<span class="built_in">end</span>(), <span class="built_in">Myprint</span>&lt;string&gt;());</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>typedef：<br>张三 李四 王五 赵六<br>using：<br>张三 李四 王五 赵六</p>
</blockquote>
<p>​		可以明显看出，用typedef给模板起别名的时候，明显地冗杂。而用using不仅相对轻巧，代码的可读性也大大的提高。但不能用函数类型定义函数的实体。</p>
<h1 id="面向对象特性"><a href="#面向对象特性" class="headerlink" title="面向对象特性"></a>面向对象特性</h1><h2 id="类成员变量的快速初始化"><a href="#类成员变量的快速初始化" class="headerlink" title="类成员变量的快速初始化"></a>类成员变量的快速初始化</h2><p>​		在C++98中支持”就地声明”初始化类中的静态成员<strong>常量</strong>,即通过等号&#x3D;赋予初始值，非静态成员变量的初始化必须在构造函数中声明。非<code>const static</code>则需要在类外初始化。但在C++11中，可以通过就地方式来实现非静态变量的初始化。但设想一下，如果一个类内都定义了就地初始化和构造函数声明初始化，最后一个执行的是谁呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>():<span class="built_in">b1</span>(<span class="string">&quot;构造函数声明初始化&quot;</span>) &#123;&#125;;<span class="comment">//构造函数声明初始化</span></span><br><span class="line">	<span class="comment">//static int a = 20;//错误，非常量的静态变量必须在类外定义</span></span><br><span class="line">	string b1 = <span class="string">&quot;就地初始化&quot;</span>;<span class="comment">//就地初始化</span></span><br><span class="line">	string b2&#123;<span class="string">&quot;另一种就地初始化方式&quot;</span>&#125;;<span class="comment">//就地初始化</span></span><br><span class="line">	<span class="comment">//int b2( 1 );//错误的初始化方式</span></span><br><span class="line">	<span class="type">const</span> <span class="type">static</span> <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;<span class="comment">//静态常量可以在类内定义</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	cout &lt;&lt; p1.b1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p> 构造函数声明初始化</p>
</blockquote>
<p>​			可以看出，字符串变量<code>b1</code>保留的是构造函数声明初始化的值，所以编译器是先进行就地初始化，再进行构造函数声明初始化。</p>
<h2 id="final和override关键字的使用"><a href="#final和override关键字的使用" class="headerlink" title="final和override关键字的使用"></a>final和override关键字的使用</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>​		<code>final</code>放在类或虚函数的后面，限制某个类不能被继承或虚函数不能被重写。注意，修饰函数时只能修饰虚函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal class&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;<span class="comment">//一般不会在基类虚函数中添加final</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">final</span>:<span class="keyword">public</span> Animal &#123;		<span class="comment">//Cat类不能再被继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">shout</span><span class="params">()</span><span class="keyword">final</span> </span>&#123;				<span class="comment">//虚函数不能在被重写</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;cat class&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>​			C++11新标准中提供<code>override</code>关键字来说明派生类中的虚函数。主要的用途是便于在调试的时候发现派生类同名函数的写错，因为这种情况在调试中是非常难发现的，并且是程序员的意图更加清晰。但如果用<code>override</code>标记了未覆盖已存在的虚函数，编译器将会报错。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal class&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:<span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">shout</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;cat class&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h2><h3 id="委托构造函数的引入"><a href="#委托构造函数的引入" class="headerlink" title="委托构造函数的引入"></a>委托构造函数的引入</h3><p>小明和李华给外国友人写信从高中写到了考研写累了，突然想唱歌，为了方便这哥俩唱歌，咱写了个唱歌类给他们。这哥俩唱的不好，就限制他俩只能唱三句。因为有1~3句的选择，就写三个构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingSong</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SingSong</span>(string first_lyric) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;first = first_lyric;</span><br><span class="line">		cout &lt;&lt; first_lyric &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">SingSong</span>(string first_lyric, string sec_lyric) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;first = first_lyric;<span class="comment">//冗余</span></span><br><span class="line">		cout &lt;&lt; first_lyric &lt;&lt; endl;<span class="comment">//冗余</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;second = sec_lyric;</span><br><span class="line">		cout &lt;&lt; sec_lyric &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">SingSong</span>(string first_lyric, string sec_lyric, string third_lyric) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;first = first_lyric;<span class="comment">//冗余</span></span><br><span class="line">		cout &lt;&lt; first_lyric &lt;&lt; endl;<span class="comment">//冗余</span></span><br><span class="line">		<span class="keyword">this</span>-&gt; second= sec_lyric;<span class="comment">//冗余</span></span><br><span class="line">		cout &lt;&lt; sec_lyric &lt;&lt; endl;<span class="comment">//冗余</span></span><br><span class="line">		<span class="keyword">this</span>-&gt; third= third_lyric;</span><br><span class="line">		cout &lt;&lt; third_lyric &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	string first;</span><br><span class="line">	string second;</span><br><span class="line">	string third;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>之后把麦给他俩，放飞自我就行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;小明想唱歌,唱了一句夜曲&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="function">SingSong <span class="title">XiaoMing</span><span class="params">(<span class="string">R&quot;(</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			一群嗜血的蚂蚁</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			被腐肉所吸引)&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;李华看小明唱开了，也想唱两句:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="function">SingSong <span class="title">LiHua</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="string">R&quot;(</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			一群嗜血的蚂蚁</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			被腐肉所吸引)&quot;,</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			R&quot;(失去你 </span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			爱恨开始分明</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			失去你 </span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			还有什么事好关心)&quot;</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>很不碰巧，被周杰伦看到了，周杰伦看他俩唱的这样就像洗洗耳朵。周杰伦一代天王，可以给他重写个演唱会类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">concert</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">concert</span>(string first_lyric) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;first = first_lyric;</span><br><span class="line">		cout &lt;&lt; first_lyric &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//委托构造函数</span></span><br><span class="line">	<span class="built_in">concert</span>(string first_lyric,string sec_lyric) :<span class="built_in">concert</span>(first_lyric) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;second = sec_lyric;</span><br><span class="line">		cout &lt;&lt; sec_lyric &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">concert</span>(string first_lyric, string sec_lyric, string third_lyric) :<span class="built_in">concert</span>(first_lyric, sec_lyric) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;third = third_lyric;</span><br><span class="line">		cout &lt;&lt; third_lyric &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	string first;</span><br><span class="line">	string second;</span><br><span class="line">	string third;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>之后周杰伦就能唱歌了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">concert <span class="title">Jay</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="string">R&quot;(</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			当鸽子不再象征和平</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			我终于被提醒</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			广场上喂食的是秃鹰</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			我用漂亮的押韵</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			形容被掠夺一空的爱情)&quot;,D</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">		R&quot;(</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			啊 乌云开始遮蔽</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			夜色不干净</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			公园里 葬礼的回音</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			在漫天飞行</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			送你的 白色玫瑰</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			在纯黑的环境凋零)&quot;,</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">		R&quot;(</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			乌鸦在树枝上诡异的很安静</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			静静听 我黑色的大衣</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			想温暖你 日渐冰冷的回忆</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">			走过的 走过的 生命)&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br></pre></td></tr></table></figure>

<p>以上代码都能正确运行。但仔细看一下代码，就能发现小明和李华的唱歌类有好多冗余的代码，而周杰伦的演唱会类就精简了很多。演唱会类的实现是用了C++11标准中的委托构造函数。委托构造函数的优点就是，减少了重复代码的出现，从两个类对比可以发现，<code>concert</code>类可以充分利用之前写的构造函数来实现有更多功能的构造函数。</p>
<h3 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h3><ol>
<li>不能出现”委托环“,一个类中若有多个委托函数，只能按链状调用，首尾不能相连。</li>
<li>如果要使用委托构造函数，不能在函数体内部调用构造函数，否则会提示形参重定义。要在初始列表中调用构造函数。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">error</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">error</span>(<span class="type">bool</span> err1) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;可以运行&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">error</span>(<span class="type">bool</span> err1, <span class="type">bool</span> err2) &#123;</span><br><span class="line">		<span class="built_in">error</span>(err1);<span class="comment">//错误,形参err1重定义</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>委托函数初始化一个变量后，就不能再次初始化该变量</li>
</ol>
<h2 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Father</span>(<span class="type">int</span> v):<span class="built_in">val_a</span>(v)&#123;&#125;</span><br><span class="line">	<span class="built_in">Father</span>(<span class="type">int</span> v1,<span class="type">int</span> v2):<span class="built_in">Father</span>(v1) &#123;</span><br><span class="line">		val_b = v2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func_similar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用父类的func_similar函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func_same</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用父类的func_same函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func_virtual</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用父类的func_virtual函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> val_a;</span><br><span class="line">	<span class="type">int</span> val_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child1</span>:<span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Child1</span>(<span class="type">int</span> v):<span class="built_in">Father</span>(v)&#123;&#125;<span class="comment">//派生类继承基类的构造函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child2</span> :<span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> Father::Father;<span class="comment">//继承构造函数</span></span><br><span class="line">	<span class="keyword">using</span> Father::func_similar;<span class="comment">//继承构造函数</span></span><br><span class="line">	<span class="keyword">using</span> Father::func_same;<span class="comment">//继承构造函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func_similar</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用子类的func_similar&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func_same</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用子类的func_same&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func_virtual</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用子类的func_virtual函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>继承构造函数可以简化派生类构造函数的编写,在C++11标准前，子类要通过<strong>Child1(int v):Father(v){}<strong>的方式继承父类的构造函数，而且一次只能继承一个构造函数。C++11标准可以通过</strong>using Father::Father</strong>便可继承父类的所有构造函数。</p>
<p>另外，c++规则中，如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏。如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏。通过using的方式可以在子类中使用父类的隐藏函数。但如果子类函数与父类函数同名同参数或者虚函数依旧是按照子类函数调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function">Child2 <span class="title">son</span><span class="params">(<span class="number">701</span>,<span class="number">1020</span>)</span></span>;</span><br><span class="line">	son.<span class="built_in">func_same</span>();<span class="comment">//同名同参数</span></span><br><span class="line">	son.<span class="built_in">func_similar</span>();<span class="comment">//同名不同参数</span></span><br><span class="line">	son.<span class="built_in">func_virtual</span>();<span class="comment">//虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>调用子类的func_same<br>调用父类的func_similar函数<br>调用子类的func_virtual函数</p>
</blockquote>
<h2 id="可调用对象包装器，绑定器"><a href="#可调用对象包装器，绑定器" class="headerlink" title="可调用对象包装器，绑定器"></a>可调用对象包装器，绑定器</h2><p><a href="https://www.cnblogs.com/tuapu/p/14167159.html#%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1">C++ 11中的std::bind和std::function - _FeiFei - 博客园 (cnblogs.com)</a></p>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>lambda表达式时C++11引入的一个新特性，相比其他编程语言，C++引入lambda表达式算晚的。引入lambda表达式后，可以就地匿名定义目标函数或函数对象，并捕获一定范围内的变量。他的使用语法如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture](params) opt -&gt; ret &#123;body;&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><em>capture</em> 是捕获列表</p>
<ul>
<li>[] - 不捕捉任何变量</li>
<li>[&amp;] - 捕获外部作用域中所有变量，并作为引用在函数体内使用 (按引用捕获)</li>
<li>[&#x3D;] - 捕获外部作用域中所有变量，并作为副本在函数体内使用 (按值捕获)<br><em>拷贝的副本在匿名函数体内部是只读的</em></li>
<li>[&#x3D;, &amp;foo] - 按值捕获外部作用域中所有变量，并按照引用捕获外部变量 foo</li>
<li>[bar] - 按值捕获 bar 变量，同时不捕获其他变量</li>
<li>[&amp;bar] - 按引用捕获 bar 变量，同时不捕获其他变量</li>
<li>[this] - 捕获当前类中的 this 指针<br><em>让 lambda 表达式拥有和当前类成员函数同样的访问权限</em><br><em>如果已经使用了 &amp; 或者 &#x3D;, 默认添加此选项</em></li>
</ul>
</li>
<li><p><em>params</em> 是参数表,可以省略不写</p>
</li>
<li><p><em>opt</em> 是函数选项</p>
<ul>
<li><p><code>mutable</code>: 因为用[&#x3D;]方式捕获的数据副本在匿名函数体内部是只读不可修改的，通过 <em>mutable</em> 选项可以修改按值传递进来的拷贝</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">auto</span> func1 = [=] &#123;</span><br><span class="line">	a++;<span class="comment">//错误,使用值拷贝的方式捕获外部变量，可读不能写</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//实现可读写外部捕获的值有两种方式</span></span><br><span class="line"><span class="comment">//默认状态下 lambda 表达式无法修改通过复制方式捕获外部变量，如果希望修改这些外部变量，需要通过引用的方式进行捕获</span></span><br><span class="line"><span class="keyword">auto</span> func2 = [&amp;] &#123;</span><br><span class="line">	a++;<span class="comment">//正确</span></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//被mutable修改是lambda表达式就算没有参数也要写明参数列表，并且可以去掉按值捕获的外部变量的只读（const）属性</span></span><br><span class="line"><span class="keyword">auto</span> func3 = [=]() <span class="keyword">mutable</span>&#123;</span><br><span class="line">	a++;<span class="comment">//正确</span></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
</li>
<li><p><code>exception</code>:指定函数抛出的异常</p>
</li>
</ul>
</li>
<li><p><em>ret</em> 是返回值类型，通常采用返回类型后置的方法定义</p>
<ul>
<li>C++11 中允许省略 lambda 表达式的返回值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 忽略返回值的lambda表达式定义</span></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">10</span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>编译器会根据 return 语句自动推导返回值的类型，但<em>labmda</em>表达式不能通过列表初始化自动推导出返回值类型。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// error，不能推导出返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> f1 = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;	<span class="comment">// 基于列表初始化推导返回值，错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><em>body</em> 是函数体</p>
</li>
</ul>
<h1 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h1><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>在介绍右值引用之前，先阐述一下左值和右值的概念。左值可以不严格的理解为等号左边的值，右值不严格的理解为等号右边的值。比如<code>int a=2</code>，<code>a</code>即为左值，<code>2</code>是右值。左值严格上讲是在内存中存储，可取地址的数据；而右值是可以提供的数据，不可取地址。<code>a</code>在内存中是有4B的存储空间的，而<code>2</code>只是一个数，<code>a</code>所指的内存空间中存放着2，内存中没有数字2对应的存储地址。所以区分左右值的一个便捷方法就是看他能否取地址。</p>
<p>C++11中的右值可以分为两种</p>
<ul>
<li><strong>纯右值</strong> 非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和 lambda 表达式等。如<code>int value=11</code>中的11.</li>
<li><strong>将亡值</strong> 与右值引用相关的表达式，比如，T&amp;&amp; 类型函数的返回值、 <code>std::move</code> 的返回值等</li>
</ul>
<p>右值是没有名称的，使用右值只能借助引用的方式，但如果对右值进行修改，只通过左值引用是行不通的。C++11通过”&amp;&amp;”进行右值引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp; value=<span class="number">10</span>;<span class="comment">//右值引用</span></span><br><span class="line"><span class="type">int</span> num=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp; var=num;<span class="comment">//错误，右值引用不能初始化为左值</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>引用类型</th>
<th>可以引用的</th>
<th>值类型</th>
<th></th>
<th></th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>非常量左值</td>
<td>常量左值</td>
<td>非常量右值</td>
<td>常量右值</td>
<td></td>
<td></td>
</tr>
<tr>
<td>非常量左值引用</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>无</td>
</tr>
<tr>
<td>常量左值引用</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>常用于类中构建拷贝构造函数</td>
</tr>
<tr>
<td>非常量右值引用</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>移动语义、完美转发</td>
</tr>
<tr>
<td>常量右值引用</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>无实际用途</td>
</tr>
</tbody></table>
<h2 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h2><p>函数中如果有类的局部变量，调用结束后会自动调用析构函数。析构函数中一般要包含对开辟的对空间的回收。假设一个类中包含着指针类型变量，这个指针指向一段新开辟的堆空间，当我们把这个类返回值传给主函数中的一个接收变量（如下列程序中 <code>demo obj1 = test();</code> 语句），调用 <code>demo obj1 = test();</code> 的时候调用拷贝构造函数对返回的临时对象进行了深拷贝得到了对象 <code>obj1</code>，在<code> test()</code> 函数中创建的对象虽然进行了内存的申请操作，但是没有使用就释放掉了（VS、codeblocks对编译器做了优化，不会出现上述现象)。这显然与预期的结果是不符的。解决这个问题就需要移动构造函数出场了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">demo</span>() :<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//(深)拷贝构造函数</span></span><br><span class="line">	<span class="built_in">demo</span>(<span class="type">const</span> demo&amp; d) :<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*d.num)) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;copy construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//移动构造函数</span></span><br><span class="line">	<span class="built_in">demo</span>(demo&amp;&amp; d) :<span class="built_in">num</span>(d.num) &#123;</span><br><span class="line">		d.num = <span class="literal">NULL</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;move construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">demo</span>() &#123;</span><br><span class="line">		<span class="keyword">delete</span> num;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;class destruct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span>* num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">demo <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	demo obj;</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    demo &amp;&amp;obj1 = <span class="built_in">test</span>();<span class="comment">//&amp;&amp;有无均可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移动构造函数的参数为右值引用类型，函数并没有开辟新的堆空间，进行的是浅拷贝。当<code>obj1</code>接收到了临时变量中的<code>num</code>地址后，讲临时变量中的<code>*num</code>指向NULL，之后进行析构时是将临时变量中的<code>*num</code>所指地址回收，回收的是NULL，而<code>obj1</code>中的指针所指地址并未受到影响。</p>
<p>右侧对象是一个临时对象才会调用移动构造函数，如果没有移动构造函数会调用拷贝构造函数。</p>
<h2 id="转移和完美转发"><a href="#转移和完美转发" class="headerlink" title="转移和完美转发"></a>转移和完美转发</h2><h3 id="转移方法move"><a href="#转移方法move" class="headerlink" title="转移方法move"></a>转移方法move</h3><p>使用<code>std::move</code>方法可以将左值转换为右值。使用这个函数并不能移动任何东西，而是和移动构造函数一样都具有移动语义，将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存拷贝。</p>
<p><code>move</code>的应用场景有两个</p>
<ul>
<li>右值引用传递变为左值，如果想传递右值引用，可以使用<code>move</code>。</li>
</ul>
<p>定义两个方法输出左值还是右值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;左值&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span>&amp;&amp; i)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;右值&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>move</code>前：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward</span><span class="params">(<span class="type">int</span>&amp;&amp; i)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printValue</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">214</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;printValue(i):&quot;</span>;</span><br><span class="line">	<span class="built_in">printValue</span>(i);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;printValue(214):&quot;</span>;</span><br><span class="line">	<span class="built_in">printValue</span>(<span class="number">214</span>);</span><br><span class="line">	<span class="comment">//右值引用传递变为左值</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;oassValue(214):&quot;</span>;</span><br><span class="line">	<span class="built_in">passValue</span>(<span class="number">214</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>printValue(i):左值<br>printValue(214):右值<br>oassValue(214):左值</p>
</blockquote>
<p><em>使用move后</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">passValue</span><span class="params">(<span class="type">int</span>&amp;&amp; i)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printValue</span>(<span class="built_in">move</span>(i));<span class="comment">//使用move方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">214</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;printValue(i):&quot;</span>;</span><br><span class="line">	<span class="built_in">printValue</span>(i);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;printValue(214):&quot;</span>;</span><br><span class="line">	<span class="built_in">printValue</span>(<span class="number">214</span>);</span><br><span class="line">	<span class="comment">//右值引用传递变为左值</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;oassValue(214):&quot;</span>;</span><br><span class="line">	<span class="built_in">passValue</span>(<span class="number">214</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>printValue(i):左值<br>printValue(214):右值<br>oassValue(214):右值</p>
</blockquote>
<ul>
<li>另一个用途就是当一个变量不在使用后，如果新的变量需要使用老变量的数据，可以使用<code>move</code>方法将老变量的数据转移给新变量。\</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;v1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v2=<span class="built_in">move</span>(v1);<span class="comment">//将v1的数据转移给v2</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v3=v1;<span class="comment">//将v1的数据转移给v3，然而此时v1已经是空，所以v3转移了个寂寞</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v1:&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> c : v1)</span><br><span class="line">		cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v2:&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> c : v2)</span><br><span class="line">		cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v3:&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> c : v3)</span><br><span class="line">		cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>v1:<br>v2:1 2 3<br>v3:</p>
</blockquote>
<h3 id="完美转发方法forward"><a href="#完美转发方法forward" class="headerlink" title="完美转发方法forward"></a>完美转发方法forward</h3><p>右值引用类型是独立于值的，一个右值引用作为函数参数的形参时，在函数内部转发该参数给内部其他函数时，它就变成一个左值，并不是原来的类型了。如果需要按照参数原来的类型转发到另一个函数，可以使用 C++11 提供的 <code>std::forward () </code>函数，该函数实现的功能称之为完美转发。</p>
<p>转发的规则是，左值引用转换为左值，非左值引用统统转换成右值。</p>
<p>写一个判断左右值的方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RorL</span><span class="params">(T&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printValue</span>(v);</span><br><span class="line">	<span class="built_in">printValue</span>(<span class="built_in">move</span>(v));</span><br><span class="line">	<span class="built_in">printValue</span>(forward&lt;T&gt;(v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//完美转发</span></span><br><span class="line">	<span class="built_in">RorL</span>(<span class="number">612</span>);<span class="comment">//参数为右值，但右值经过传递为左值，move将参数转换为右值，forward保留原始的右值属性</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">612</span>;</span><br><span class="line">	<span class="built_in">RorL</span>(num);<span class="comment">//参数为左值，move转为右值，forward保留原始左值属性</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">RorL</span>(forward&lt;<span class="type">int</span>&gt;(num));<span class="comment">//参数为左值，move转为右值，forward模板参数为右值引用，推导为右值</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">RorL</span>(forward&lt;<span class="type">int</span>&amp;&gt;(num));<span class="comment">//参数为左值，move转为右值，forward模板参数为左值引用，推导为左值</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">RorL</span>(forward&lt;<span class="type">int</span>&amp;&amp;&gt;(num));<span class="comment">//参数为左值，move转为右值，forward模板参数为右值引用，推导为右值</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>左值<br>右值<br>右值</p>
<p>左值<br>右值<br>左值</p>
<p>左值<br>右值<br>右值</p>
<p>左值<br>右值<br>左值</p>
<p>左值<br>右值<br>右值</p>
</blockquote>
<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>在现代 C++ 编程中，标准库包含智能指针，该指针用于确保程序不存在内存和资源泄漏且是异常安全的。智能指针是在<code>&lt;memory&gt; </code>头文件中的 <code>std</code> 命名空间中定义的。</p>
<p>C++ 中没有垃圾回收机制，必须自己释放分配的内存。智能指针的引用可以帮助程序员管理动态分配的内存，自动释放申请来的内存，避免内存泄漏。</p>
<h2 id="共享智能指针-share-ptr"><a href="#共享智能指针-share-ptr" class="headerlink" title="共享智能指针 share_ptr"></a>共享智能指针 share_ptr</h2><p>共享智能指针是指多个智能指针可以同时管理同一块有效的内存，共享智能指针 shared_ptr 是一个模板类。</p>
<p><code>share_ptr</code>通过引用计数的方式实现多个share_ptr对象之间的共享资源。在对象销毁时，引用计数减一，当引用计数为0时，释放该资源。</p>
<h3 id="share-ptr的初始化"><a href="#share-ptr的初始化" class="headerlink" title="share_ptr的初始化"></a>share_ptr的初始化</h3><ul>
<li>通过构造函数初始化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">11</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过拷贝构造函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">ptr2</span>(ptr1);</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt;ptr3 = ptr1;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过移动构造函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">ptr4</span>(std::<span class="built_in">move</span>(ptr1));</span><br></pre></td></tr></table></figure>

<p>移动构造函数在移动语义中阐述过，通过这种方式初始化，相当于将ptr1的资源转让给ptr4。一个很好的演示方法是智能指针的<code>use_count()</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">11</span>))</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr1引用计数&quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">ptr2</span>(std::<span class="built_in">move</span>(ptr1));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr1引用计数&quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr2引用计数&quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p><strong>运算结果</strong></p>
<blockquote>
<p>ptr1引用计数1<br>ptr1引用计数0<br>ptr2引用计数1</p>
</blockquote>
<ul>
<li>通过make_shared初始化</li>
</ul>
<p> <code>std::make_shared()</code> 就可以完成内存对象的创建并将其初始化给智能指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr5 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">2023</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>通过reset初始化</li>
</ul>
<p><code>std::shared_ptr::reset</code>对于一个未初始化的共享智能指针，可以通过<code>reset</code>方法来初始化，当智能指针中有值的时候，调用<code>reset</code>会使引用计数减 1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ptr5.<span class="built_in">reset</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr5引用计数&quot;</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">ptr5.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">99</span>));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr5引用计数&quot;</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>ptr5引用计数0<br>ptr5引用计数1</p>
</blockquote>
<h3 id="创建和析构类对象"><a href="#创建和析构类对象" class="headerlink" title="创建和析构类对象"></a>创建和析构类对象</h3><p>因为<code>share_ptr</code>是一个模板类，它对任何数据类型都适用。当它创建一个类对象时，何时调用构造函数，何时调用析构函数，下面的代码展示出了通过<code>make_shared</code>方法构造智能指针和通过<code>reset</code>方法释放及重定向智能指针的例子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">	string str;</span><br><span class="line">	<span class="built_in">Test</span>()</span><br><span class="line">	&#123;	</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;创建类对象&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Test</span>(string str)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;str = str;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;创建类对象, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Test</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构类对象,str = &quot;</span>&lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> para)</span></span>&#123;</span><br><span class="line">		value = para;</span><br><span class="line">		cout &lt;&lt; value&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//智能指针创建和析构类对象</span></span><br><span class="line">	std::shared_ptr&lt;Test&gt;ptr_class1 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">	std::shared_ptr&lt;Test&gt;ptr_class3 =ptr_class1;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ptr_class3引用计数&quot;</span> &lt;&lt; ptr_class3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	std::shared_ptr&lt;Test&gt;ptr_class2 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">	ptr_class1.<span class="built_in">reset</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ptr_class3引用计数&quot;</span> &lt;&lt; ptr_class3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	ptr_class3.<span class="built_in">reset</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ptr_class3引用计数&quot;</span> &lt;&lt; ptr_class3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	ptr_class2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="string">&quot;C++11&quot;</span>));	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ptr_class2引用计数&quot;</span> &lt;&lt; ptr_class2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>创建类对象, str &#x3D; C++<br>ptr_class3引用计数2<br>创建类对象, str &#x3D; java<br>ptr_class3引用计数1<br>析构类对象,str &#x3D; C++<br>ptr_class3引用计数0<br>创建类对象, str &#x3D; C++11<br>析构类对象,str &#x3D; java<br>ptr_class2引用计数1<br>析构类对象,str &#x3D; C++11</p>
</blockquote>
<p>通过运行结果可以看出，通过<code>make_shared</code>创建的智能指针对象会调用类的构造函数，通过智能指针的拷贝构造函数创建新的智能指针并不再调用类的构造函数。在引用计数为0时才调用类的析构函数。如果通过<code>reset</code>重定向智能指针并开辟新的堆空间，也会调用类的构造函数。</p>
<h3 id="获取原始指针"><a href="#获取原始指针" class="headerlink" title="获取原始指针"></a>获取原始指针</h3><p>共享智能指针类提供<code>get</code>方法可以得到原始地址。得到的结果就是一个指针，通过指针的使用的方法可以调用该数据结构里的各种数据和方法。还是以上一小节中的<code>test</code>类为例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;Test&gt;ptr_class = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">Test* raw = ptr_class.<span class="built_in">get</span>();</span><br><span class="line">raw-&gt;<span class="built_in">setValue</span>(<span class="number">2</span>);<span class="comment">//raw为指向类对象的指针</span></span><br></pre></td></tr></table></figure>

<h3 id="指定删除器"><a href="#指定删除器" class="headerlink" title="指定删除器"></a>指定删除器</h3><p>当智能指针管理的内存对应的引用计数变为 0 的时候，这块内存就会被智能指针析构掉了。另外，我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为删除器，这个删除器函数本质是一个回调函数。</p>
<p>删除器可以用函数实现，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteIntPtr</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int 型内存被释放了...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">250</span>), deleteIntPtr)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用 <em>lambda</em> 表达式实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;Test&gt;<span class="built_in">ptr_del</span>(<span class="keyword">new</span> Test, [](Test* t) &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;自定义智能指针删除器&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> t;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>lambda表达式的参数就是智能指针管理的内存的地址，有了这个地址之后函数体内部就可以完成删除操作了。C++11提供了一个默认的删除器<code>std::default_delete&lt;T&gt;()</code> ，通过<code>delete</code>来实现。但如果智能指针管理的是数组对象，需要在默认删除器中指定数组类型。(但在C++11之后的标准中支持未指定删除器的智能指针数组的写法)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;Test&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> Test[<span class="number">2</span>], default_delete&lt;Test[]&gt;())</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>创建类对象<br>创建类对象<br>析构类对象,str &#x3D;<br>析构类对象,str &#x3D;</p>
</blockquote>
<h2 id="独占智能指针unique-ptr"><a href="#独占智能指针unique-ptr" class="headerlink" title="独占智能指针unique_ptr"></a>独占智能指针unique_ptr</h2><p><code>std::unique_ptr</code>是一个独占型的智能指针，它不允许其他的智能指针共享其内部的指针，可以通过它的构造函数初始化一个独占智能指针对象，但是不允许通过赋值将一个 unique_ptr 赋值给另一个 unique_ptr。</p>
<p>由于<code>unique_ptr</code>不允许复制，所以它的初始化方式就两种。一种通过构造函数<code>new</code>一段堆空间，另一种是通过前面讲述的<code>move</code>方法转移所有权。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//独占智能指针的两种初始化</span></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">2</span>));</span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">ptr2</span>(<span class="built_in">move</span>(ptr1));</span><br></pre></td></tr></table></figure>

<p>在指定删除器上，<code>unique_ptr</code> 指定删除器的时候需要确定删除器的类型，不能像 <code>shared_ptr</code> 那样直接指定删除器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>* p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>上述代码错在没有确定删除器的类型，<em>lambda</em> 表达式在未捕获任何变量的情况下可以转换为一个函数指针。不过一旦<em>lambda</em> 表达式捕获了一个变量就不能转换为函数指针了，导致编译器报错。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>*);</span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>, func_ptr&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;<span class="comment">//ok</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>, func_ptr&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [&amp;](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p;&#125;)</span></span>;<span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<p>如果想让编译器成功编译，需要使用可调用对象包装器来处理声明的函数指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;<span class="type">int</span>, function&lt;<span class="type">void</span>(<span class="type">int</span>*)&gt;&gt; <span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>), [&amp;](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;);</span><br></pre></td></tr></table></figure>

<p>另外，在管理数组类型的地址时，能够自动释放。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//独占智能指针可以管理数组类型的地址能够自动释放</span></span><br><span class="line">std::unique_ptr&lt;Test[]&gt;<span class="built_in">ptr_arr_unique</span>(<span class="keyword">new</span> Test[<span class="number">3</span>]);</span><br><span class="line"><span class="comment">//shared_ptr不支持未指定删除器的智能指针数组的写法，但C++11之后可以支持</span></span><br><span class="line">std::shared_ptr&lt;Test[]&gt;<span class="built_in">ptr_arr_share</span>(<span class="keyword">new</span> Test[<span class="number">3</span>]);<span class="comment">//C++11不允许</span></span><br></pre></td></tr></table></figure>

<h2 id="弱引用智能指针weak-ptr"><a href="#弱引用智能指针weak-ptr" class="headerlink" title="弱引用智能指针weak_ptr"></a>弱引用智能指针weak_ptr</h2><p><code>std::weak_ptr</code> 更像是一个辅助，用来弥补智能指针的一些不足。弱引用指针只监测资源，不管理资源，它的构造不会增加引用计数，析构也不会减少引用计数。</p>
<h3 id="weak-ptr的语法"><a href="#weak-ptr的语法" class="headerlink" title="weak_ptr的语法"></a>weak_ptr的语法</h3><ul>
<li>初始化</li>
</ul>
<p><code>weak_ptr</code>的初始化很简单朴素，依赖于<code>shared_ptr</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">share</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">weak_ptr&lt;<span class="type">int</span>&gt; wp1;</span><br><span class="line">wp1=share;</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp2</span><span class="params">(share)</span></span>;</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp3</span><span class="params">(wp1)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>use_count()</code></li>
</ul>
<p>通过调用 std::weak_ptr 类提供的 use_count() 方法可以获得当前所观测资源的引用计数</p>
<ul>
<li><code>expired()</code></li>
</ul>
<p>判断观测的资源是否已经被释放</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">share.<span class="built_in">reset</span>();</span><br><span class="line">cout &lt;&lt; wp1.<span class="built_in">expired</span>() &lt;&lt; endl;<span class="comment">//返回值为布尔类型,1:释放，0：未释放</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>lock()</code></li>
</ul>
<p> 获取管理所监测资源的 <code>shared_ptr</code> 对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">share1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">2</span>))</span></span>;</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">weak</span><span class="params">(share1)</span></span>;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; share2;</span><br><span class="line">share2 = weak.<span class="built_in">lock</span>();<span class="comment">//share2指向了weak所指资源</span></span><br><span class="line">cout &lt;&lt; *share2.<span class="built_in">get</span>();<span class="comment">//打印所指资源</span></span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>2</p>
</blockquote>
<h3 id="解决指向this的智能指针的双重析构"><a href="#解决指向this的智能指针的双重析构" class="headerlink" title="解决指向this的智能指针的双重析构"></a>解决指向this的智能指针的双重析构</h3><p>如果在类中用智能指针指向一个类中的<code>this</code>指针时，当这个类生存周期结束进行析构时，会被析构两次。两次分别被类析构函数析构一次，智能指针删除器删除智能指针，再次调用类的析构函数对这个资源再次析构，从而导致程序崩溃。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">getSharedPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Test&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class Test is disstruct ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个问题可以通过<code>weak_ptr</code>解决，前文已经了解到，<code>weak_ptr</code>只监测资源而不管理资源，如果用一个弱引用智能指针指向<code>this</code>，析构两次的问题就得到解决了。C++11提供了<code>std::enable_shared_from_this&lt;T&gt;</code>模板类，通过调用其中的<code>shared_from_this()</code>方法，便可以得到一个检测<code>this</code>的<code>weak_ptr</code>。</p>
<h3 id="解决循环引用问题"><a href="#解决循环引用问题" class="headerlink" title="解决循环引用问题"></a>解决循环引用问题</h3><p>如果有两个不同类对象A和B，类对象A用智能指ap针指向了类对象B的智能指针bp，然后bp又指向了ap，造成了智能指针的循环引用问题。共享智能指针 ap、bp 对 A、B 实例对象的引用计数变为 2，在共享智能指针离开作用域之后引用计数只能减为1，这种情况下不会去删除智能指针管理的内存，导致类 TA、TB 的实例对象不能被析构，最终造成内存泄露。</p>
<p>这类问题的解决很容易，像解决死锁问题的思路一样，把循环打破就可以了。将其中的一个智能指针改成弱引用指针便可以解决问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    weak_ptr&lt;B&gt; bptr;</span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class A is disstruct ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    shared_ptr&lt;A&gt; aptr;</span><br><span class="line">    ~<span class="built_in">B</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class B is disstruct ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">bp</span><span class="params">(<span class="keyword">new</span> B)</span></span>;</span><br><span class="line">    ap-&gt;bptr = bp;</span><br><span class="line">    bp-&gt;aptr = ap</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<blockquote>
<p>class B is disstruct …<br>class A is disstruct …</p>
</blockquote>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>十大排序算法</title>
    <url>/2023/03/04/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>本文用C++阐述十大排序算法的升降序实现方法。</p>
<ul>
<li>交换排序（冒泡，快排）</li>
<li>插入排序（简单插入，希尔）</li>
<li>选择排序、堆排序</li>
<li>归并排序</li>
<li>基数排序，计数排序，桶排序</li>
</ul>
<span id="more"></span>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png" alt="img"></p>
<p>开篇前先将随机数生成函数与打印容器的函数对象置于此</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVec</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">randData</span><span class="params">(vector&lt;T&gt;&amp; a, <span class="type">int</span> n,<span class="type">int</span> random=<span class="number">99</span>)</span>    <span class="comment">//产生n个0-99的随机数，用于创建随机数组用来作为排序前数列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">typeid</span>(T) == <span class="built_in">typeid</span>(<span class="type">char</span>)) &#123;<span class="comment">//字符型随机数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            a[i] = <span class="string">&#x27;a&#x27;</span> + <span class="built_in">rand</span>() % <span class="number">26</span>;</span><br><span class="line">                cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">typeid</span>(T) == <span class="built_in">typeid</span>(<span class="type">int</span>)) &#123;<span class="comment">//整型随机数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i] = <span class="built_in">rand</span>() % random;</span><br><span class="line">                cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">typeid</span>(T) == <span class="built_in">typeid</span>(<span class="type">double</span>)) &#123;<span class="comment">//浮点型随机数</span></span><br><span class="line">        uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="built_in">u</span>(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="function">default_random_engine <span class="title">e</span><span class="params">(time(<span class="literal">NULL</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">u</span>(e) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="比较排序"><a class="header-anchor" href="#比较排序">¶</a>比较排序</h2>
<p>比较排序（Comparison Sort）通过对数组中的元素进行比较来实现排序。</p>
<p>动画演示平台 <a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">Comparison Sorting Visualization (usfca.edu)</a></p>
<h3 id="交换排序"><a class="header-anchor" href="#交换排序">¶</a>交换排序</h3>
<h4 id="冒泡排序"><a class="header-anchor" href="#冒泡排序">¶</a>冒泡排序</h4>
<ul>
<li>稳定</li>
<li>时间复杂度最好为 <em><strong>O(n)</strong></em> ,最差为 <em><strong>O(n<sup>2</sup>)</strong></em> ,平均 <em><strong>O(n<sup>2</sup>)</strong></em></li>
<li>空间复杂度 <em><strong>O(1)</strong></em></li>
<li>原地算法</li>
</ul>
<p><strong>思路</strong></p>
<p>从左到右，依次比较相邻的元素大小，更大（小）的元素交换到右边。类似水中的气泡一样，先让大（小）的元素浮上去。</p>
<p><strong><em>tip</em> 用一个布尔类型变量充当哨兵，如果一趟遍历没有任何元素发生交换，说明该数列已经有序。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;T&gt;&amp; nums, <span class="type">bool</span> is_increase = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> guard = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//升序排序</span></span><br><span class="line">    <span class="keyword">if</span> (is_increase) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            guard = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//此时已经有i个元素已经到达了预期的位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; nums.<span class="built_in">size</span>() - (i + <span class="number">1</span>);j++) &#123;</span><br><span class="line">                <span class="comment">//如果当前元素值比下一元素数据值大，交换</span></span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    guard = <span class="literal">false</span>;</span><br><span class="line">                    T tmp = nums[j];</span><br><span class="line">                    nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                    nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (guard)</span><br><span class="line">                <span class="keyword">return</span>;<span class="comment">//如果一趟遍历中没有发生任何交换说明数组已经有序了</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//降序排序</span></span><br><span class="line">    <span class="comment">//思路同升序相似</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            guard = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; nums.<span class="built_in">size</span>() - (i + <span class="number">1</span>);j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    guard = <span class="literal">false</span>;</span><br><span class="line">                    T tmp = nums[j];</span><br><span class="line">                    nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                    nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (guard)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums ;</span><br><span class="line"><span class="built_in">randData</span>(nums, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">bubbleSort</span>&lt;<span class="type">int</span>&gt;(nums,<span class="number">0</span>);<span class="comment">//降序</span></span><br><span class="line"><span class="built_in">bubbleSort</span>&lt;<span class="type">int</span>&gt;(nums);<span class="comment">//升序</span></span><br><span class="line">for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), printVec&lt;<span class="type">int</span>&gt;);</span><br></pre></td></tr></table></figure>
<h4 id="快速排序"><a class="header-anchor" href="#快速排序">¶</a>快速排序</h4>
<ul>
<li>不稳定</li>
<li>最坏情况发生在数据有序情况下，时间复杂度为<em><strong>O(n<sup>2</sup>)</strong></em></li>
<li>平均时间复杂度和最好情况时间复杂度均为<em><strong>O(n*log n)</strong></em></li>
<li>空间复杂度<em><strong>O(n*log n)</strong></em></li>
<li>原地算法</li>
</ul>
<p><strong>思路</strong></p>
<ol>
<li>选取数组第一个元素作为基准</li>
<li>依次从右向左挑选一个比基准数值小的元素和从左到右挑选一个比基准数值大的元素，并交换位置。最终使得数据值比基准大的放在基准元素左边，数值比基准小的放在基准元素右边。基准元素置于中间。</li>
<li>递归地把小于基准值元素的子数列和大于基准值元素的子数列按上述方法排序</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;T&gt;&amp; nums, <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">bool</span> is_increase)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//令第一个数组元素为枢纽元素</span></span><br><span class="line">    T pivot = nums[low];</span><br><span class="line">    <span class="comment">//升序排序</span></span><br><span class="line">    <span class="keyword">if</span> (is_increase) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="comment">//从右向左找比枢纽元素小的数组元素</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] &gt;= pivot)high--;</span><br><span class="line">            nums[low] = nums[high];</span><br><span class="line">            <span class="comment">//从左向右找比枢纽元素大的的数组元素</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] &lt;= pivot)low++;</span><br><span class="line">            nums[high] = nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//枢纽元素归位</span></span><br><span class="line">        nums[low] = pivot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//降序排序</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="comment">//从右向左找比枢纽元素小的数组元素</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] &lt;= pivot)high--;</span><br><span class="line">            nums[low] = nums[high];</span><br><span class="line">            <span class="comment">//从左向右找比枢纽元素大的的数组元素</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] &gt;= pivot)low++;</span><br><span class="line">            nums[high] = nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//枢纽元素归位</span></span><br><span class="line">        nums[low] = pivot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快排</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qSort</span><span class="params">(vector&lt;T&gt;&amp; nums, <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">bool</span> is_increase = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pivot = <span class="built_in">partition</span>(nums, low, high, is_increase);</span><br><span class="line">        <span class="built_in">qSort</span>(nums, low, pivot - <span class="number">1</span>, is_increase);</span><br><span class="line">        <span class="built_in">qSort</span>(nums, pivot + <span class="number">1</span>, high, is_increase);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums ;</span><br><span class="line"><span class="built_in">randData</span>(nums, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">qSort</span>&lt;<span class="type">int</span>&gt;(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//降序</span></span><br><span class="line"><span class="built_in">qSort</span>&lt;<span class="type">int</span>&gt;(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);<span class="comment">//升序</span></span><br><span class="line">for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), printVec&lt;<span class="type">int</span>&gt;);</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a class="header-anchor" href="#插入排序">¶</a>插入排序</h3>
<h4 id="简单插入排序"><a class="header-anchor" href="#简单插入排序">¶</a>简单插入排序</h4>
<ul>
<li>稳定</li>
<li><em><strong>O(n<sup>2</sup>)</strong></em> 的最坏和平均时间复杂度，最好情况 <em><strong>O(n)</strong></em></li>
<li><em><strong>O(1)</strong></em> 的空间复杂度</li>
<li>原地算法</li>
</ul>
<p><strong>思路</strong></p>
<ul>
<li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li>
<li>从头到尾依次扫描未排序序列，将扫描到的每个元素与有序序列的每个元素进行比较，小于哪个有序序列的元素就进行交换，相当于插入到该元素索引位置。</li>
</ul>
<p><strong><em>tip</em> 容器的第一个元素可以默认为有序序列，所以第一层循环可以从i=1出发</strong></p>
<p><strong>代码</strong></p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;T&gt;&amp; nums, <span class="type">bool</span> is_increase = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    T tmp;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">if</span> (is_increase) &#123;<span class="comment">//升序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            tmp = nums[i];</span><br><span class="line">            <span class="comment">//将该元素放在已排序元素的适当位置</span></span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; nums[j - <span class="number">1</span>] &gt; tmp; j--)</span><br><span class="line">                nums[j] = nums[j - <span class="number">1</span>]; <span class="comment">//位置不合适将排序好的元素后挪</span></span><br><span class="line">            nums[j] = tmp; </span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//降序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            tmp = nums[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; nums[j - <span class="number">1</span>] &lt; tmp; j--)</span><br><span class="line">                nums[j] = nums[j - <span class="number">1</span>]; </span><br><span class="line">            nums[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums ;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;原始数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">randData</span>(nums, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">insertSort</span>&lt;<span class="type">int</span>&gt;(nums,<span class="number">0</span>);<span class="comment">//降序</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;降序数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), printVec&lt;<span class="type">int</span>&gt;);</span><br><span class="line"><span class="built_in">insertSort</span>&lt;<span class="type">int</span>&gt;(nums);<span class="comment">//升序</span></span><br><span class="line">cout &lt;&lt; endl&lt;&lt;<span class="string">&quot;升序数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), printVec&lt;<span class="type">int</span>&gt;);</span><br></pre></td></tr></table></figure>
<h4 id="希尔排序"><a class="header-anchor" href="#希尔排序">¶</a>希尔排序</h4>
<p>1959年Shell发明，第一个突破 O(n2) 的排序算法，是插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<em>缩小增量排序</em>。</p>
<ul>
<li>不稳定</li>
<li>平均时间复杂度<em><strong>O(n<sup>1.3</sup>)</strong></em>，最好<em><strong>O(n)</strong></em>，最坏<em><strong>O(n<sup>2</sup>)</strong></em></li>
<li>空间复杂度<em><strong>O(1)</strong></em></li>
<li>原地算法</li>
</ul>
<p><strong>思路</strong></p>
<ol>
<li>选择一个增量序列 t1，t2，…，tk，其中 ti&gt;tj，tk=1；</li>
<li>按增量序列个数 k，对序列进行 k 趟排序；</li>
<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ol>
<p><strong><em>tip</em> 最简单的思路就是先按照插入排序写，在外层再套一层循环，使步长坐标处的元素按照步长间距来进行插入排序。</strong></p>
<p><strong>参照</strong> <a href="https://www.bilibili.com/video/BV1mt4y1Q7d4/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c35acf9464abdbb34e8a162472f57ef5">4希尔排序代码_哔哩哔哩_bilibili</a></p>
<p>每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。</p>
<p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;T&gt;&amp;nums, <span class="type">bool</span> is_increase = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    T tmp;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">if</span> (is_increase) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> step = nums.<span class="built_in">size</span>() / <span class="number">2</span>;step;step /= <span class="number">2</span>) &#123;<span class="comment">//相当于将数列分为若干个子数列，进行多次插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = step;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">                tmp = nums[i];</span><br><span class="line">                <span class="keyword">for</span> (j = i;j &gt;= step &amp;&amp; nums[j - step] &gt; tmp;j -= step) &#123;<span class="comment">//按照步长间隔进行插入排序</span></span><br><span class="line">                    nums[j] = nums[j - step];</span><br><span class="line">                &#125;</span><br><span class="line">                nums[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> step = nums.<span class="built_in">size</span>() / <span class="number">2</span>;step;step /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = step;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">                tmp = nums[i];</span><br><span class="line">                <span class="keyword">for</span> (j = i;j &gt;= step &amp;&amp; nums[j - step] &lt; tmp;j -= step) &#123;</span><br><span class="line">                    nums[j] = nums[j - step];</span><br><span class="line">                &#125;</span><br><span class="line">                nums[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums ;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;原始数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">randData</span>(nums, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">shellSort</span>&lt;<span class="type">int</span>&gt;(nums,<span class="number">0</span>);<span class="comment">//降序</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;降序数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), printVec&lt;<span class="type">int</span>&gt;);</span><br><span class="line"><span class="built_in">insertSort</span>&lt;<span class="type">int</span>&gt;(nums);<span class="comment">//升序</span></span><br><span class="line">cout &lt;&lt; endl&lt;&lt;<span class="string">&quot;升序数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), printVec&lt;<span class="type">int</span>&gt;);</span><br></pre></td></tr></table></figure>
<h3 id="选择排序"><a class="header-anchor" href="#选择排序">¶</a>选择排序</h3>
<h4 id="简单选择排序"><a class="header-anchor" href="#简单选择排序">¶</a>简单选择排序</h4>
<ul>
<li>不稳定</li>
<li>时间复杂度最好最坏平均都为 <em><strong>(n<sup>2</sup>)</strong></em></li>
<li>空间复杂度<em><strong>O(1)</strong></em></li>
<li>原地算法</li>
<li>每一趟<code>n-i+1(i=1,2,…,n-1)</code>个记录中选取值最小的索引作为有序序列的第 i 个索引。</li>
</ul>
<p><strong>思路</strong></p>
<ol>
<li>
<p>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置;</p>
</li>
<li>
<p>在剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾;</p>
</li>
<li>
<p>重复步骤 2，直到所有元素排序完毕。</p>
</li>
</ol>
<p><strong><em>tip</em> 因为每一趟便将一个元素放到正确的位置上，所以当容器中的n-1个元素已经归位时，此时容器已经是有序数列了。</strong></p>
<p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(vector&lt;T&gt;&amp; nums, <span class="type">bool</span> is_increase = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> min_index;</span><br><span class="line">    <span class="type">int</span> max_index;</span><br><span class="line">    T tmp;</span><br><span class="line">    <span class="keyword">if</span> (is_increase) &#123;</span><br><span class="line">        <span class="comment">//循环找到最小的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            min_index = i;<span class="comment">//min_index记录了该趟遍历过程中的最小元素的下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>;j &lt; nums.<span class="built_in">size</span>();j++) &#123;</span><br><span class="line">                <span class="comment">//如果遍历到的元素小于记录的最小值，最小值所指下标进行更新</span></span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[min_index])</span><br><span class="line">                    min_index = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将此趟遍历得到的结果交换到数列的前部</span></span><br><span class="line">            tmp = nums[i];</span><br><span class="line">            nums[i] = nums[min_index];</span><br><span class="line">            nums[min_index] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//降序</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//循环找到最大的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            max_index = i;<span class="comment">//max_index记录了该趟遍历过程中的最大元素的下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>;j &lt; nums.<span class="built_in">size</span>();j++) &#123;</span><br><span class="line">                <span class="comment">//如果遍历到的元素大于记录的最大值，最大值所指下标进行更新</span></span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[max_index])</span><br><span class="line">                    max_index = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将此趟遍历得到的结果交换到数列的前部</span></span><br><span class="line">            tmp = nums[i];</span><br><span class="line">            nums[i] = nums[max_index];</span><br><span class="line">            nums[max_index] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums ;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;原始数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">randData</span>(nums, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">selectSort</span>&lt;<span class="type">int</span>&gt;(nums,<span class="number">0</span>);<span class="comment">//降序</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;降序数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), printVec&lt;<span class="type">int</span>&gt;);</span><br><span class="line"><span class="built_in">selectSort</span>&lt;<span class="type">int</span>&gt;(nums);<span class="comment">//升序</span></span><br><span class="line">cout &lt;&lt; endl&lt;&lt;<span class="string">&quot;升序数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), printVec&lt;<span class="type">int</span>&gt;);</span><br></pre></td></tr></table></figure>
<h4 id="堆排序"><a class="header-anchor" href="#堆排序">¶</a>堆排序</h4>
<p><strong>动画展示</strong> <a href="https://www.cs.usfca.edu/~galles/visualization/HeapSort.html">Heap Sort Visualization (usfca.edu)</a></p>
<ul>
<li>不稳定，适合数据量较大的序列</li>
<li>时间复杂度最好最坏平均都为<em><strong>O(n*log n)</strong></em></li>
<li>空间复杂度<em><strong>O(1)</strong></em></li>
<li>原地算法</li>
</ul>
<p><strong>思路</strong></p>
<ol>
<li>
<p>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</p>
</li>
<li>
<p>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</p>
</li>
<li>
<p>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</p>
</li>
</ol>
<p>堆积内部是完全二叉树的结构，并且用数组存放。所以可以根据父节点坐标求出子节点的坐标。设父节点坐标为<code>i</code>（从0开始），则左孩子<code>2 * i + 1</code>，右孩子<code>2 * i + 2</code>。也可以通过孩子结点反推出父节点下标，设孩子结点为j，则 <code>i=(j-1)/2</code>，因为整数÷2会舍弃小数，所以不需要区分左右孩子情况。</p>
<p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjustHeap</span><span class="params">(vector&lt;T&gt;&amp; heap,<span class="type">int</span> root,<span class="type">int</span> end,<span class="type">bool</span> is_increase)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//end为堆尾元素下标</span></span><br><span class="line">    <span class="comment">//若根节点为叶子结点，返回</span></span><br><span class="line">    <span class="keyword">if</span> (root*<span class="number">2</span>+<span class="number">1</span> &gt; end)<span class="keyword">return</span>;</span><br><span class="line">    T tmp;</span><br><span class="line">    <span class="comment">//根据父节点下标求左右孩子下标</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * root + <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> max_or_min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//升序，建立大根堆</span></span><br><span class="line">    <span class="keyword">if</span> (is_increase) &#123;</span><br><span class="line">        <span class="comment">//比较父节点的左右子树，选取值大的结点</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; end) <span class="comment">//有两个孩子结点</span></span><br><span class="line">            max_or_min = heap[left] &gt; heap[right] ? left : right;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//只有左孩子</span></span><br><span class="line">            max_or_min = left;</span><br><span class="line">        <span class="comment">//调整为大根堆</span></span><br><span class="line">        <span class="keyword">if</span> (heap[root] &lt; heap[max_or_min]) &#123;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            tmp = heap[max_or_min];</span><br><span class="line">            heap[max_or_min] = heap[root];</span><br><span class="line">            heap[root] = tmp;</span><br><span class="line">            <span class="comment">//交换后的结点向下也构成大根堆</span></span><br><span class="line">            <span class="built_in">adjustHeap</span>(heap, max_or_min, end, is_increase);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//降序，建立小根堆</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//比较父节点的左右子树，选取值小的结点</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; end) <span class="comment">//有两个孩子结点</span></span><br><span class="line">            max_or_min = heap[left] &lt; heap[right] ? left : right;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//只有左孩子</span></span><br><span class="line">            max_or_min = left;</span><br><span class="line">        <span class="comment">//调整为小根堆</span></span><br><span class="line">        <span class="keyword">if</span> (heap[root] &gt; heap[max_or_min]) &#123;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            tmp = heap[max_or_min];</span><br><span class="line">            heap[max_or_min] = heap[root];</span><br><span class="line">            heap[root] = tmp;</span><br><span class="line">            <span class="comment">//交换后的结点向下也构成小根堆</span></span><br><span class="line">            <span class="built_in">adjustHeap</span>(heap, max_or_min, end, is_increase);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildHeap</span><span class="params">(vector&lt;T&gt;&amp; heap, <span class="type">int</span> end, <span class="type">bool</span> is_increase)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//end 为堆尾元素下标</span></span><br><span class="line">    <span class="comment">//获取最靠后的非叶子结点的坐标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (end - <span class="number">1</span>) / <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="built_in">adjustHeap</span>(heap, i, end, is_increase);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;T&gt;&amp; heap, <span class="type">bool</span> is_increase=<span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    T tmp;</span><br><span class="line">    <span class="comment">//构建堆</span></span><br><span class="line">    <span class="built_in">buildHeap</span>(heap, heap.<span class="built_in">size</span>() - <span class="number">1</span>, is_increase);</span><br><span class="line">    <span class="comment">//堆顶元素与无序数列最后一个元素交换，堆顶元素加入到有序队列，构建新的堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = heap.<span class="built_in">size</span>() - <span class="number">1</span>;i;i--) &#123;</span><br><span class="line">        tmp=heap[i];</span><br><span class="line">        heap[i] = heap[<span class="number">0</span>];</span><br><span class="line">        heap[<span class="number">0</span>] = tmp;</span><br><span class="line">        <span class="built_in">buildHeap</span>(heap, i<span class="number">-1</span>, is_increase);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums ;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;原始数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">randData</span>(nums, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">heapSort</span>&lt;<span class="type">int</span>&gt;(nums,<span class="number">0</span>);<span class="comment">//降序</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;降序数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), printVec&lt;<span class="type">int</span>&gt;);</span><br><span class="line"><span class="built_in">heapSort</span>&lt;<span class="type">int</span>&gt;(nums);<span class="comment">//升序</span></span><br><span class="line">cout &lt;&lt; endl&lt;&lt;<span class="string">&quot;升序数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), printVec&lt;<span class="type">int</span>&gt;);</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a class="header-anchor" href="#归并排序">¶</a>归并排序</h3>
<ul>
<li>稳定</li>
<li>时间复杂度平均最坏最好均为<em><strong>O(n*logn)</strong></em></li>
<li>空间复杂度<em><strong>O(n)</strong></em></li>
<li>非原地算法，占用额外空间</li>
</ul>
<p><strong>思路</strong></p>
<ol>
<li>把长度为 n 的输入序列分成两个长度为 n/2 的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ol>
<p><strong>代码</strong></p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;T&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> mid, <span class="type">bool</span> is_increase)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//left,right都为闭区间,mid为序列中间元素下标</span></span><br><span class="line">    vector&lt;T&gt; left_vec;</span><br><span class="line">    vector&lt;T&gt; right_vec;</span><br><span class="line">    <span class="comment">//左多右少</span></span><br><span class="line">    left_vec.<span class="built_in">resize</span>(mid - left + <span class="number">1</span>);</span><br><span class="line">    right_vec.<span class="built_in">resize</span>(right - mid);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; right_vec.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        left_vec[i] = nums[left + i];</span><br><span class="line">        right_vec[i] = nums[i + mid+ <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    left_vec[mid - left] = nums[mid];</span><br><span class="line">    <span class="comment">//两段进行归并排序</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//升序实现</span></span><br><span class="line">    <span class="keyword">while</span> (is_increase &amp;&amp; i &lt; left_vec.<span class="built_in">size</span>() &amp;&amp; j &lt; right_vec.<span class="built_in">size</span>())</span><br><span class="line">        nums[left++] = left_vec[i] &lt; right_vec[j] ? left_vec[i++] : right_vec[j++];</span><br><span class="line">    <span class="comment">//降序实现</span></span><br><span class="line">    <span class="keyword">while</span> (!is_increase &amp;&amp; i &lt; left_vec.<span class="built_in">size</span>() &amp;&amp; j &lt; right_vec.<span class="built_in">size</span>() )</span><br><span class="line">        nums[left++] = left_vec[i] &gt; right_vec[j] ? left_vec[i++] : right_vec[j++];</span><br><span class="line">    <span class="comment">//归并段剩余元素处理</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; left_vec.<span class="built_in">size</span>())nums[left++] = left_vec[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; right_vec.<span class="built_in">size</span>())nums[left++] = right_vec[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;T&gt;&amp; nums, <span class="type">bool</span> is_increase = <span class="literal">true</span>,<span class="type">int</span> start=<span class="number">0</span> , <span class="type">int</span> end=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    start:待排序列的起始下标，默认值为0</span></span><br><span class="line"><span class="comment">    end:待排序列的结尾下标，默认值为-1，表示排序容器所有元素</span></span><br><span class="line"><span class="comment">    is_increase：值为1时按升序排列，值为0时按降序排列</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (end == <span class="number">-1</span>)end = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">if</span> (start == end)<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//左右分治</span></span><br><span class="line">    <span class="type">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(nums, is_increase, start, mid);</span><br><span class="line">    <span class="built_in">mergeSort</span>(nums, is_increase , mid+<span class="number">1</span>, end);</span><br><span class="line">    <span class="built_in">merge</span>(nums, start, end, mid, is_increase);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums ;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;原始数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">randData</span>(nums, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">mergeSort</span>&lt;<span class="type">int</span>&gt;(nums,<span class="literal">false</span>);<span class="comment">//降序</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;降序数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), printVec&lt;<span class="type">int</span>&gt;);</span><br><span class="line"><span class="built_in">mergeSort</span>&lt;<span class="type">int</span>&gt;(nums, <span class="literal">true</span>,<span class="number">5</span>,<span class="number">25</span>);<span class="comment">//局部升序</span></span><br><span class="line">cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;局部升序数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), printVec&lt;<span class="type">int</span>&gt;);</span><br><span class="line"><span class="built_in">mergeSort</span>&lt;<span class="type">int</span>&gt;(nums,<span class="literal">true</span>);<span class="comment">//升序</span></span><br><span class="line">cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;升序数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), printVec&lt;<span class="type">int</span>&gt;);</span><br><span class="line"><span class="built_in">mergeSort</span>&lt;<span class="type">int</span>&gt;(nums, <span class="literal">false</span>, <span class="number">5</span>, <span class="number">25</span>);<span class="comment">//局部降序</span></span><br><span class="line">cout &lt;&lt;endl&lt;&lt; <span class="string">&quot;局部降序数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), printVec&lt;<span class="type">int</span>&gt;);</span><br></pre></td></tr></table></figure>
<h2 id="非比较排序"><a class="header-anchor" href="#非比较排序">¶</a>非比较排序</h2>
<p>非比较排序分为三种，桶排序，计数排序和基数排序。</p>
<h3 id="桶排序"><a class="header-anchor" href="#桶排序">¶</a>桶排序</h3>
<p><strong>动画展示</strong> <a href="https://www.cs.usfca.edu/~galles/visualization/BucketSort.html">Bucket Sort Visualization (usfca.edu)</a></p>
<p>桶排序 （Bucket sort）是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶（一定的区间范围）里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）</p>
<ul>
<li>桶排序是<strong>稳定排序</strong>，但仅限于桶排序本身，假如桶内排序采用了快速排序之类的非稳定排序，那么就是不稳定的。</li>
<li>时间复杂度最好情况<em><strong>O(n+k)</strong></em> ，最坏情况 <em><strong>O(n<sup>2</sup>)</strong></em></li>
<li>空间复杂度<em><strong>O(n+k)</strong></em></li>
</ul>
<p><strong>思路</strong></p>
<ol>
<li>设置一个定量的数组当作空桶；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bucketSort</span><span class="params">(vector&lt;T&gt;&amp;nums,<span class="type">int</span> bucket_size ,<span class="type">void</span> (*func)(vector&lt;T&gt;&amp;,<span class="type">bool</span>), <span class="type">bool</span> is_increase = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//bucket_size为桶的个数</span></span><br><span class="line">    <span class="comment">//(*func)为一个函数指针，指向所指向的排序方法</span></span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//确定桶大小</span></span><br><span class="line">    T max=nums[<span class="number">0</span>], min=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; max)max = num;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; min)min = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> bucket_range = (max - min+<span class="number">1</span>) / bucket_size + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//待排序元素对应入桶</span></span><br><span class="line">    vector&lt; vector&lt;T&gt; &gt; <span class="built_in">bucket</span>(bucket_size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) </span><br><span class="line">        bucket[(num - min) / bucket_range].<span class="built_in">push_back</span>(num);</span><br><span class="line">    <span class="comment">//桶内元素排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; bucket_size;i++) </span><br><span class="line">        <span class="built_in">func</span>(bucket[i], is_increase);</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//升序</span></span><br><span class="line">    <span class="keyword">if</span> (is_increase) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> arr : bucket)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> data : arr)</span><br><span class="line">                nums[index++] = data;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//降序</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = bucket.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> data : bucket[i])</span><br><span class="line">                nums[index++] = data;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//using type = int;</span></span><br><span class="line"><span class="keyword">using</span> type = <span class="type">char</span>;</span><br><span class="line"><span class="comment">//using type = double;</span></span><br><span class="line">vector&lt;type&gt; nums ;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;原始数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">randData</span>(nums, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">bucketSort</span>&lt;type&gt;(nums,<span class="number">4</span>,shellSort);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;升序数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), printVec&lt;type&gt;);</span><br><span class="line">cout &lt;&lt; endl&lt;&lt;<span class="string">&quot;降序数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">bucketSort</span>&lt;type&gt;(nums, <span class="number">4</span>, countSort,<span class="number">0</span>);</span><br><span class="line">for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), printVec&lt;type&gt;);</span><br></pre></td></tr></table></figure>
<h3 id="计数排序"><a class="header-anchor" href="#计数排序">¶</a>计数排序</h3>
<p><strong>动画展示</strong> <a href="https://www.cs.usfca.edu/~galles/visualization/CountingSort.html">Counting Sort Visualization (usfca.edu)</a></p>
<ul>
<li>适用于量大但是数的取值范围区间小的情况</li>
<li>稳定，<strong>升序的计数数组按从前到后的方式累加，所以计数数组的元素值从前至后增大；反向取数，可以同样大小的数后出现的在靠后的位置，保持了排序的稳定性。而降序，相同大小的值a、b，若a在b的左边，降序排列后a应在b的右边以保持稳定性。降序的计数数组按从后到前的方式累加，所以计数数组的元素值从前至后减小；越早出现的元素应在降序中是更靠后的位置，所以降序应当从前到后取数。结合代码理解</strong></li>
<li>时间复杂度 <em><strong>O(n+k)</strong></em></li>
<li>空间复杂度 <em><strong>O(n+k)</strong></em></li>
<li>非原地算法</li>
</ul>
<p><strong><em>tips</em> k为计数数组的长度</strong></p>
<p><strong>思路</strong></p>
<ol>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；</li>
<li>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去 1。</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计数排序</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">countSort_pre</span><span class="params">(vector&lt;T&gt; nums, <span class="type">bool</span> is_increase)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)<span class="keyword">return</span> nums;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">typeid</span>(T) != <span class="built_in">typeid</span>(<span class="type">int</span>) &amp;&amp; <span class="built_in">typeid</span>(T) != <span class="built_in">typeid</span>(<span class="type">short</span>) &amp;&amp; <span class="built_in">typeid</span>(T) != <span class="built_in">typeid</span>(<span class="type">char</span>)&amp;&amp;<span class="built_in">typeid</span>(T) != <span class="built_in">typeid</span>(<span class="type">long</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;计数排序只能排序整型和字符型数据&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找最大值和最小值</span></span><br><span class="line">    T min = nums[<span class="number">0</span>], max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; max)max = num;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; min)min = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//建立计数数组</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;counting;</span><br><span class="line">    vector&lt;T&gt;tmp;<span class="comment">//暂存排序结果并用于返回结果</span></span><br><span class="line">    counting.<span class="built_in">resize</span>(max - min + <span class="number">1</span>,<span class="number">0</span>);<span class="comment">//数组元素默认值为0</span></span><br><span class="line">    tmp.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">//处理计数数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) <span class="comment">//将待排序数列的元素值出现个数统计到计数数组中</span></span><br><span class="line">        counting[num - min]++;</span><br><span class="line">    <span class="keyword">if</span> (is_increase) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; counting.<span class="built_in">size</span>();i++)     <span class="comment">//升序，计数数组数值从前到后累加</span></span><br><span class="line">            counting[i] += counting[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//反向从待排序数组取数，放到tmp中计数数组数值对应的下标位置，取出后计数数组中的值-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">            tmp[--counting[nums[i] - min]] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = counting.<span class="built_in">size</span>()<span class="number">-2</span>;i&gt;=<span class="number">0</span> ;i--)     <span class="comment">//降序，计数数组数值从后向前累加</span></span><br><span class="line">            counting[i] += counting[i + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//正向从待排序数组取数，放到tmp中计数数组数值对应的下标位置，取出后计数数组中的值-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            tmp[--counting[nums[i] - min]] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countSort</span><span class="params">(vector&lt;T&gt;&amp; nums, <span class="type">bool</span> is_increase=<span class="literal">true</span>)</span>  </span>&#123;</span><br><span class="line">     <span class="comment">//只接受整数和字符类型容器，否则捕获异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       nums=<span class="built_in">countSort_pre</span>(nums,is_increase);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">        cerr &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//using type = int;//测试整型</span></span><br><span class="line"><span class="keyword">using</span> type = <span class="type">char</span>;<span class="comment">//测试字符型</span></span><br><span class="line"><span class="comment">//using type = double;//测试浮点型</span></span><br><span class="line">vector&lt;type&gt; nums ;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;原始数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">randData</span>(nums, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">countSort</span>&lt;type&gt;(nums);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;升序数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), printVec&lt;type&gt;);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;降序数据:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">countSort</span>&lt;type&gt;(nums,<span class="number">0</span>);</span><br><span class="line">for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), printVec&lt;type&gt;);</span><br></pre></td></tr></table></figure>
<h3 id="基数排序"><a class="header-anchor" href="#基数排序">¶</a>基数排序</h3>
<p><strong>动画展示</strong> <a href="https://www.cs.usfca.edu/~galles/visualization/RadixSort.html">Radix Sort Visualzation (usfca.edu)</a></p>
<ul>
<li>稳定</li>
<li>时间复杂度 <em><strong>O(n*k)</strong></em></li>
<li>空间复杂度 <em><strong>O(n+k)</strong></em></li>
</ul>
<p><strong>思路</strong></p>
<ol>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr 为原始数组，从最低位开始取每个位组成 radix 数组；</li>
<li>对 radix 进行计数排序（利用计数排序适用于小范围数的特点）。</li>
</ol>
]]></content>
      <categories>
        <category>基础数据结构与算法思想</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>排序算法</tag>
        <tag>递归与分治</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2023/03/04/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>求next数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">getNext</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> str_len = str.<span class="built_in">size</span>();</span><br><span class="line">	<span class="type">int</span>* next = <span class="keyword">new</span> <span class="type">int</span>[str_len];<span class="comment">//为申请next数组申请内存空间</span></span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> prefix = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//比较前缀与后缀</span></span><br><span class="line">	<span class="keyword">while</span>(index&lt;str_len) &#123;</span><br><span class="line">		<span class="keyword">if</span> (str[index<span class="number">-1</span>] == str[prefix]) &#123;</span><br><span class="line">			prefix++;</span><br><span class="line">			next[index] = prefix;</span><br><span class="line">			index++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (prefix == <span class="number">0</span>) &#123;</span><br><span class="line">				next[index] = prefix;</span><br><span class="line">				index++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				prefix = next[prefix<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kmp算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMP</span><span class="params">(string pattern, string str)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//得到next数组</span></span><br><span class="line">	<span class="type">int</span>* next = <span class="built_in">getNext</span>(pattern);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;<span class="comment">//两个索引分别代表主串和模式串的下标</span></span><br><span class="line">	<span class="comment">//主串与模式进行比较</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="comment">//字符匹配则主串模式串索引均后移</span></span><br><span class="line">		<span class="keyword">if</span> (str[i] == pattern[j]||j==<span class="number">0</span>) &#123;</span><br><span class="line">			i++;j++;</span><br><span class="line">			<span class="keyword">if</span> (j &gt;= pattern.<span class="built_in">size</span>()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//不匹配，主串索引不变，模式串索引根据next数组作相应的改变</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">			j = next[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span> [] next;</span><br><span class="line">	<span class="keyword">if</span> (j == pattern.<span class="built_in">size</span>())</span><br><span class="line">		<span class="keyword">return</span> i - pattern.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础数据结构与算法思想</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
</search>
